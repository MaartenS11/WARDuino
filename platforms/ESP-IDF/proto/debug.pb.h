// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: debug.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_debug_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_debug_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_debug_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_debug_2eproto {
  static const uint32_t offsets[];
};
namespace debug {
class CallbackEntry;
struct CallbackEntryDefaultTypeInternal;
extern CallbackEntryDefaultTypeInternal _CallbackEntry_default_instance_;
class CallbackMapping;
struct CallbackMappingDefaultTypeInternal;
extern CallbackMappingDefaultTypeInternal _CallbackMapping_default_instance_;
class CallstackEntry;
struct CallstackEntryDefaultTypeInternal;
extern CallstackEntryDefaultTypeInternal _CallstackEntry_default_instance_;
class DebugMessage;
struct DebugMessageDefaultTypeInternal;
extern DebugMessageDefaultTypeInternal _DebugMessage_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class EventsQueue;
struct EventsQueueDefaultTypeInternal;
extern EventsQueueDefaultTypeInternal _EventsQueue_default_instance_;
class Function;
struct FunctionDefaultTypeInternal;
extern FunctionDefaultTypeInternal _Function_default_instance_;
class Locals;
struct LocalsDefaultTypeInternal;
extern LocalsDefaultTypeInternal _Locals_default_instance_;
class Notification;
struct NotificationDefaultTypeInternal;
extern NotificationDefaultTypeInternal _Notification_default_instance_;
class Payload;
struct PayloadDefaultTypeInternal;
extern PayloadDefaultTypeInternal _Payload_default_instance_;
class RFC;
struct RFCDefaultTypeInternal;
extern RFCDefaultTypeInternal _RFC_default_instance_;
class Range;
struct RangeDefaultTypeInternal;
extern RangeDefaultTypeInternal _Range_default_instance_;
class Snapshot;
struct SnapshotDefaultTypeInternal;
extern SnapshotDefaultTypeInternal _Snapshot_default_instance_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
}  // namespace debug
PROTOBUF_NAMESPACE_OPEN
template<> ::debug::CallbackEntry* Arena::CreateMaybeMessage<::debug::CallbackEntry>(Arena*);
template<> ::debug::CallbackMapping* Arena::CreateMaybeMessage<::debug::CallbackMapping>(Arena*);
template<> ::debug::CallstackEntry* Arena::CreateMaybeMessage<::debug::CallstackEntry>(Arena*);
template<> ::debug::DebugMessage* Arena::CreateMaybeMessage<::debug::DebugMessage>(Arena*);
template<> ::debug::Event* Arena::CreateMaybeMessage<::debug::Event>(Arena*);
template<> ::debug::EventsQueue* Arena::CreateMaybeMessage<::debug::EventsQueue>(Arena*);
template<> ::debug::Function* Arena::CreateMaybeMessage<::debug::Function>(Arena*);
template<> ::debug::Locals* Arena::CreateMaybeMessage<::debug::Locals>(Arena*);
template<> ::debug::Notification* Arena::CreateMaybeMessage<::debug::Notification>(Arena*);
template<> ::debug::Payload* Arena::CreateMaybeMessage<::debug::Payload>(Arena*);
template<> ::debug::RFC* Arena::CreateMaybeMessage<::debug::RFC>(Arena*);
template<> ::debug::Range* Arena::CreateMaybeMessage<::debug::Range>(Arena*);
template<> ::debug::Snapshot* Arena::CreateMaybeMessage<::debug::Snapshot>(Arena*);
template<> ::debug::Value* Arena::CreateMaybeMessage<::debug::Value>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace debug {

enum Notification_Type : int {
  Notification_Type_continued = 0,
  Notification_Type_halted = 1,
  Notification_Type_paused = 2,
  Notification_Type_stepped = 3,
  Notification_Type_hitbreakpoint = 4,
  Notification_Type_newevent = 5,
  Notification_Type_changeaffected = 11,
  Notification_Type_dump = 6,
  Notification_Type_dumplocals = 7,
  Notification_Type_snapshot = 8,
  Notification_Type_dumpevents = 9,
  Notification_Type_dumpcallbacks = 10,
  Notification_Type_malformed = 12,
  Notification_Type_unknown = 13,
  Notification_Type_Notification_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Notification_Type_Notification_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Notification_Type_IsValid(int value);
constexpr Notification_Type Notification_Type_Type_MIN = Notification_Type_continued;
constexpr Notification_Type Notification_Type_Type_MAX = Notification_Type_unknown;
constexpr int Notification_Type_Type_ARRAYSIZE = Notification_Type_Type_MAX + 1;

const std::string& Notification_Type_Name(Notification_Type value);
template<typename T>
inline const std::string& Notification_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Notification_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Notification_Type_Name.");
  return Notification_Type_Name(static_cast<Notification_Type>(enum_t_value));
}
bool Notification_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Notification_Type* value);
enum Value_Type : int {
  Value_Type_i32 = 0,
  Value_Type_i64 = 1,
  Value_Type_f32 = 2,
  Value_Type_f64 = 3,
  Value_Type_any = 4,
  Value_Type_Value_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Value_Type_Value_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Value_Type_IsValid(int value);
constexpr Value_Type Value_Type_Type_MIN = Value_Type_i32;
constexpr Value_Type Value_Type_Type_MAX = Value_Type_any;
constexpr int Value_Type_Type_ARRAYSIZE = Value_Type_Type_MAX + 1;

const std::string& Value_Type_Name(Value_Type value);
template<typename T>
inline const std::string& Value_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Value_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Value_Type_Name.");
  return Value_Type_Name(static_cast<Value_Type>(enum_t_value));
}
bool Value_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Value_Type* value);
enum State : int {
  WARDUINOrun = 0,
  WARDUINOpause = 1,
  WARDUINOstep = 2,
  PROXYrun = 3,
  PROXYhalt = 4,
  State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool State_IsValid(int value);
constexpr State State_MIN = WARDUINOrun;
constexpr State State_MAX = PROXYhalt;
constexpr int State_ARRAYSIZE = State_MAX + 1;

const std::string& State_Name(State value);
template<typename T>
inline const std::string& State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function State_Name.");
  return State_Name(static_cast<State>(enum_t_value));
}
bool State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, State* value);
enum Command : int {
  run = 0,
  halt = 1,
  pause = 2,
  step = 3,
  bpadd = 4,
  bprem = 5,
  dump = 6,
  dumplocals = 7,
  snapshot = 8,
  dumpevents = 9,
  dumpcallbacks = 10,
  updatefunc = 11,
  updatelocal = 12,
  updatecallbacks = 13,
  loadsnapshot = 14,
  proxify = 15,
  proxyadd = 16,
  proxyrem = 17,
  proxycall = 18,
  popevent = 19,
  pushevent = 20,
  Command_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Command_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Command_IsValid(int value);
constexpr Command Command_MIN = run;
constexpr Command Command_MAX = pushevent;
constexpr int Command_ARRAYSIZE = Command_MAX + 1;

const std::string& Command_Name(Command value);
template<typename T>
inline const std::string& Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Command_Name.");
  return Command_Name(static_cast<Command>(enum_t_value));
}
bool Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Command* value);
// ===================================================================

class DebugMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:debug.DebugMessage) */ {
 public:
  inline DebugMessage() : DebugMessage(nullptr) {}
  ~DebugMessage() override;
  explicit PROTOBUF_CONSTEXPR DebugMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugMessage(const DebugMessage& from);
  DebugMessage(DebugMessage&& from) noexcept
    : DebugMessage() {
    *this = ::std::move(from);
  }

  inline DebugMessage& operator=(const DebugMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugMessage& operator=(DebugMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DebugMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugMessage* internal_default_instance() {
    return reinterpret_cast<const DebugMessage*>(
               &_DebugMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DebugMessage& a, DebugMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DebugMessage& from);
  void MergeFrom(const DebugMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DebugMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "debug.DebugMessage";
  }
  protected:
  explicit DebugMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 2,
    kCommandFieldNumber = 1,
  };
  // optional .debug.Payload payload = 2;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::debug::Payload& payload() const;
  PROTOBUF_NODISCARD ::debug::Payload* release_payload();
  ::debug::Payload* mutable_payload();
  void set_allocated_payload(::debug::Payload* payload);
  private:
  const ::debug::Payload& _internal_payload() const;
  ::debug::Payload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::debug::Payload* payload);
  ::debug::Payload* unsafe_arena_release_payload();

  // .debug.Command command = 1;
  void clear_command();
  ::debug::Command command() const;
  void set_command(::debug::Command value);
  private:
  ::debug::Command _internal_command() const;
  void _internal_set_command(::debug::Command value);
  public:

  // @@protoc_insertion_point(class_scope:debug.DebugMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::debug::Payload* payload_;
    int command_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debug_2eproto;
};
// -------------------------------------------------------------------

class Notification final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:debug.Notification) */ {
 public:
  inline Notification() : Notification(nullptr) {}
  ~Notification() override;
  explicit PROTOBUF_CONSTEXPR Notification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Notification(const Notification& from);
  Notification(Notification&& from) noexcept
    : Notification() {
    *this = ::std::move(from);
  }

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }
  inline Notification& operator=(Notification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Notification& default_instance() {
    return *internal_default_instance();
  }
  static inline const Notification* internal_default_instance() {
    return reinterpret_cast<const Notification*>(
               &_Notification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Notification& a, Notification& b) {
    a.Swap(&b);
  }
  inline void Swap(Notification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Notification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Notification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Notification>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Notification& from);
  void MergeFrom(const Notification& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Notification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "debug.Notification";
  }
  protected:
  explicit Notification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Notification_Type Type;
  static constexpr Type continued =
    Notification_Type_continued;
  static constexpr Type halted =
    Notification_Type_halted;
  static constexpr Type paused =
    Notification_Type_paused;
  static constexpr Type stepped =
    Notification_Type_stepped;
  static constexpr Type hitbreakpoint =
    Notification_Type_hitbreakpoint;
  static constexpr Type newevent =
    Notification_Type_newevent;
  static constexpr Type changeaffected =
    Notification_Type_changeaffected;
  static constexpr Type dump =
    Notification_Type_dump;
  static constexpr Type dumplocals =
    Notification_Type_dumplocals;
  static constexpr Type snapshot =
    Notification_Type_snapshot;
  static constexpr Type dumpevents =
    Notification_Type_dumpevents;
  static constexpr Type dumpcallbacks =
    Notification_Type_dumpcallbacks;
  static constexpr Type malformed =
    Notification_Type_malformed;
  static constexpr Type unknown =
    Notification_Type_unknown;
  static inline bool Type_IsValid(int value) {
    return Notification_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Notification_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Notification_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Notification_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Notification_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Notification_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional .debug.Payload payload = 2;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::debug::Payload& payload() const;
  PROTOBUF_NODISCARD ::debug::Payload* release_payload();
  ::debug::Payload* mutable_payload();
  void set_allocated_payload(::debug::Payload* payload);
  private:
  const ::debug::Payload& _internal_payload() const;
  ::debug::Payload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::debug::Payload* payload);
  ::debug::Payload* unsafe_arena_release_payload();

  // .debug.Notification.Type type = 1;
  void clear_type();
  ::debug::Notification_Type type() const;
  void set_type(::debug::Notification_Type value);
  private:
  ::debug::Notification_Type _internal_type() const;
  void _internal_set_type(::debug::Notification_Type value);
  public:

  // @@protoc_insertion_point(class_scope:debug.Notification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::debug::Payload* payload_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debug_2eproto;
};
// -------------------------------------------------------------------

class Payload final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:debug.Payload) */ {
 public:
  inline Payload() : Payload(nullptr) {}
  ~Payload() override;
  explicit PROTOBUF_CONSTEXPR Payload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Payload(const Payload& from);
  Payload(Payload&& from) noexcept
    : Payload() {
    *this = ::std::move(from);
  }

  inline Payload& operator=(const Payload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Payload& operator=(Payload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Payload& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kSnapshot = 1,
    kLocals = 2,
    kFunction = 3,
    kBreakpoint = 4,
    kQueue = 5,
    kEvent = 6,
    kRange = 7,
    kCallbacks = 8,
    kCall = 9,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Payload* internal_default_instance() {
    return reinterpret_cast<const Payload*>(
               &_Payload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Payload& a, Payload& b) {
    a.Swap(&b);
  }
  inline void Swap(Payload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Payload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Payload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Payload>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Payload& from);
  void MergeFrom(const Payload& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Payload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "debug.Payload";
  }
  protected:
  explicit Payload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotFieldNumber = 1,
    kLocalsFieldNumber = 2,
    kFunctionFieldNumber = 3,
    kBreakpointFieldNumber = 4,
    kQueueFieldNumber = 5,
    kEventFieldNumber = 6,
    kRangeFieldNumber = 7,
    kCallbacksFieldNumber = 8,
    kCallFieldNumber = 9,
  };
  // .debug.Snapshot snapshot = 1;
  bool has_snapshot() const;
  private:
  bool _internal_has_snapshot() const;
  public:
  void clear_snapshot();
  const ::debug::Snapshot& snapshot() const;
  PROTOBUF_NODISCARD ::debug::Snapshot* release_snapshot();
  ::debug::Snapshot* mutable_snapshot();
  void set_allocated_snapshot(::debug::Snapshot* snapshot);
  private:
  const ::debug::Snapshot& _internal_snapshot() const;
  ::debug::Snapshot* _internal_mutable_snapshot();
  public:
  void unsafe_arena_set_allocated_snapshot(
      ::debug::Snapshot* snapshot);
  ::debug::Snapshot* unsafe_arena_release_snapshot();

  // .debug.Locals locals = 2;
  bool has_locals() const;
  private:
  bool _internal_has_locals() const;
  public:
  void clear_locals();
  const ::debug::Locals& locals() const;
  PROTOBUF_NODISCARD ::debug::Locals* release_locals();
  ::debug::Locals* mutable_locals();
  void set_allocated_locals(::debug::Locals* locals);
  private:
  const ::debug::Locals& _internal_locals() const;
  ::debug::Locals* _internal_mutable_locals();
  public:
  void unsafe_arena_set_allocated_locals(
      ::debug::Locals* locals);
  ::debug::Locals* unsafe_arena_release_locals();

  // .debug.Function function = 3;
  bool has_function() const;
  private:
  bool _internal_has_function() const;
  public:
  void clear_function();
  const ::debug::Function& function() const;
  PROTOBUF_NODISCARD ::debug::Function* release_function();
  ::debug::Function* mutable_function();
  void set_allocated_function(::debug::Function* function);
  private:
  const ::debug::Function& _internal_function() const;
  ::debug::Function* _internal_mutable_function();
  public:
  void unsafe_arena_set_allocated_function(
      ::debug::Function* function);
  ::debug::Function* unsafe_arena_release_function();

  // string breakpoint = 4;
  bool has_breakpoint() const;
  private:
  bool _internal_has_breakpoint() const;
  public:
  void clear_breakpoint();
  const std::string& breakpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_breakpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_breakpoint();
  PROTOBUF_NODISCARD std::string* release_breakpoint();
  void set_allocated_breakpoint(std::string* breakpoint);
  private:
  const std::string& _internal_breakpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_breakpoint(const std::string& value);
  std::string* _internal_mutable_breakpoint();
  public:

  // .debug.EventsQueue queue = 5;
  bool has_queue() const;
  private:
  bool _internal_has_queue() const;
  public:
  void clear_queue();
  const ::debug::EventsQueue& queue() const;
  PROTOBUF_NODISCARD ::debug::EventsQueue* release_queue();
  ::debug::EventsQueue* mutable_queue();
  void set_allocated_queue(::debug::EventsQueue* queue);
  private:
  const ::debug::EventsQueue& _internal_queue() const;
  ::debug::EventsQueue* _internal_mutable_queue();
  public:
  void unsafe_arena_set_allocated_queue(
      ::debug::EventsQueue* queue);
  ::debug::EventsQueue* unsafe_arena_release_queue();

  // .debug.Event event = 6;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::debug::Event& event() const;
  PROTOBUF_NODISCARD ::debug::Event* release_event();
  ::debug::Event* mutable_event();
  void set_allocated_event(::debug::Event* event);
  private:
  const ::debug::Event& _internal_event() const;
  ::debug::Event* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::debug::Event* event);
  ::debug::Event* unsafe_arena_release_event();

  // .debug.Range range = 7;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::debug::Range& range() const;
  PROTOBUF_NODISCARD ::debug::Range* release_range();
  ::debug::Range* mutable_range();
  void set_allocated_range(::debug::Range* range);
  private:
  const ::debug::Range& _internal_range() const;
  ::debug::Range* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::debug::Range* range);
  ::debug::Range* unsafe_arena_release_range();

  // .debug.CallbackMapping callbacks = 8;
  bool has_callbacks() const;
  private:
  bool _internal_has_callbacks() const;
  public:
  void clear_callbacks();
  const ::debug::CallbackMapping& callbacks() const;
  PROTOBUF_NODISCARD ::debug::CallbackMapping* release_callbacks();
  ::debug::CallbackMapping* mutable_callbacks();
  void set_allocated_callbacks(::debug::CallbackMapping* callbacks);
  private:
  const ::debug::CallbackMapping& _internal_callbacks() const;
  ::debug::CallbackMapping* _internal_mutable_callbacks();
  public:
  void unsafe_arena_set_allocated_callbacks(
      ::debug::CallbackMapping* callbacks);
  ::debug::CallbackMapping* unsafe_arena_release_callbacks();

  // .debug.RFC call = 9;
  bool has_call() const;
  private:
  bool _internal_has_call() const;
  public:
  void clear_call();
  const ::debug::RFC& call() const;
  PROTOBUF_NODISCARD ::debug::RFC* release_call();
  ::debug::RFC* mutable_call();
  void set_allocated_call(::debug::RFC* call);
  private:
  const ::debug::RFC& _internal_call() const;
  ::debug::RFC* _internal_mutable_call();
  public:
  void unsafe_arena_set_allocated_call(
      ::debug::RFC* call);
  ::debug::RFC* unsafe_arena_release_call();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:debug.Payload)
 private:
  class _Internal;
  void set_has_snapshot();
  void set_has_locals();
  void set_has_function();
  void set_has_breakpoint();
  void set_has_queue();
  void set_has_event();
  void set_has_range();
  void set_has_callbacks();
  void set_has_call();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::debug::Snapshot* snapshot_;
      ::debug::Locals* locals_;
      ::debug::Function* function_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr breakpoint_;
      ::debug::EventsQueue* queue_;
      ::debug::Event* event_;
      ::debug::Range* range_;
      ::debug::CallbackMapping* callbacks_;
      ::debug::RFC* call_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debug_2eproto;
};
// -------------------------------------------------------------------

class Snapshot final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:debug.Snapshot) */ {
 public:
  inline Snapshot() : Snapshot(nullptr) {}
  ~Snapshot() override;
  explicit PROTOBUF_CONSTEXPR Snapshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Snapshot(const Snapshot& from);
  Snapshot(Snapshot&& from) noexcept
    : Snapshot() {
    *this = ::std::move(from);
  }

  inline Snapshot& operator=(const Snapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Snapshot& operator=(Snapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Snapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Snapshot* internal_default_instance() {
    return reinterpret_cast<const Snapshot*>(
               &_Snapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Snapshot& a, Snapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(Snapshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Snapshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Snapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Snapshot>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Snapshot& from);
  void MergeFrom(const Snapshot& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Snapshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "debug.Snapshot";
  }
  protected:
  explicit Snapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBreakpointsFieldNumber = 3,
    kFunctionsFieldNumber = 4,
    kCallstackFieldNumber = 5,
    kLocalsFieldNumber = 6,
    kQueueFieldNumber = 7,
    kCallbacksFieldNumber = 8,
    kProgramCounterFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // repeated string breakpoints = 3;
  int breakpoints_size() const;
  private:
  int _internal_breakpoints_size() const;
  public:
  void clear_breakpoints();
  const std::string& breakpoints(int index) const;
  std::string* mutable_breakpoints(int index);
  void set_breakpoints(int index, const std::string& value);
  void set_breakpoints(int index, std::string&& value);
  void set_breakpoints(int index, const char* value);
  void set_breakpoints(int index, const char* value, size_t size);
  std::string* add_breakpoints();
  void add_breakpoints(const std::string& value);
  void add_breakpoints(std::string&& value);
  void add_breakpoints(const char* value);
  void add_breakpoints(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& breakpoints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_breakpoints();
  private:
  const std::string& _internal_breakpoints(int index) const;
  std::string* _internal_add_breakpoints();
  public:

  // repeated .debug.Function functions = 4;
  int functions_size() const;
  private:
  int _internal_functions_size() const;
  public:
  void clear_functions();
  ::debug::Function* mutable_functions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Function >*
      mutable_functions();
  private:
  const ::debug::Function& _internal_functions(int index) const;
  ::debug::Function* _internal_add_functions();
  public:
  const ::debug::Function& functions(int index) const;
  ::debug::Function* add_functions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Function >&
      functions() const;

  // repeated .debug.CallstackEntry callstack = 5;
  int callstack_size() const;
  private:
  int _internal_callstack_size() const;
  public:
  void clear_callstack();
  ::debug::CallstackEntry* mutable_callstack(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::CallstackEntry >*
      mutable_callstack();
  private:
  const ::debug::CallstackEntry& _internal_callstack(int index) const;
  ::debug::CallstackEntry* _internal_add_callstack();
  public:
  const ::debug::CallstackEntry& callstack(int index) const;
  ::debug::CallstackEntry* add_callstack();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::CallstackEntry >&
      callstack() const;

  // optional .debug.Locals locals = 6;
  bool has_locals() const;
  private:
  bool _internal_has_locals() const;
  public:
  void clear_locals();
  const ::debug::Locals& locals() const;
  PROTOBUF_NODISCARD ::debug::Locals* release_locals();
  ::debug::Locals* mutable_locals();
  void set_allocated_locals(::debug::Locals* locals);
  private:
  const ::debug::Locals& _internal_locals() const;
  ::debug::Locals* _internal_mutable_locals();
  public:
  void unsafe_arena_set_allocated_locals(
      ::debug::Locals* locals);
  ::debug::Locals* unsafe_arena_release_locals();

  // optional .debug.EventsQueue queue = 7;
  bool has_queue() const;
  private:
  bool _internal_has_queue() const;
  public:
  void clear_queue();
  const ::debug::EventsQueue& queue() const;
  PROTOBUF_NODISCARD ::debug::EventsQueue* release_queue();
  ::debug::EventsQueue* mutable_queue();
  void set_allocated_queue(::debug::EventsQueue* queue);
  private:
  const ::debug::EventsQueue& _internal_queue() const;
  ::debug::EventsQueue* _internal_mutable_queue();
  public:
  void unsafe_arena_set_allocated_queue(
      ::debug::EventsQueue* queue);
  ::debug::EventsQueue* unsafe_arena_release_queue();

  // optional .debug.CallbackMapping callbacks = 8;
  bool has_callbacks() const;
  private:
  bool _internal_has_callbacks() const;
  public:
  void clear_callbacks();
  const ::debug::CallbackMapping& callbacks() const;
  PROTOBUF_NODISCARD ::debug::CallbackMapping* release_callbacks();
  ::debug::CallbackMapping* mutable_callbacks();
  void set_allocated_callbacks(::debug::CallbackMapping* callbacks);
  private:
  const ::debug::CallbackMapping& _internal_callbacks() const;
  ::debug::CallbackMapping* _internal_mutable_callbacks();
  public:
  void unsafe_arena_set_allocated_callbacks(
      ::debug::CallbackMapping* callbacks);
  ::debug::CallbackMapping* unsafe_arena_release_callbacks();

  // uint32 program_counter = 1;
  void clear_program_counter();
  uint32_t program_counter() const;
  void set_program_counter(uint32_t value);
  private:
  uint32_t _internal_program_counter() const;
  void _internal_set_program_counter(uint32_t value);
  public:

  // .debug.State state = 2;
  void clear_state();
  ::debug::State state() const;
  void set_state(::debug::State value);
  private:
  ::debug::State _internal_state() const;
  void _internal_set_state(::debug::State value);
  public:

  // @@protoc_insertion_point(class_scope:debug.Snapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> breakpoints_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Function > functions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::CallstackEntry > callstack_;
    ::debug::Locals* locals_;
    ::debug::EventsQueue* queue_;
    ::debug::CallbackMapping* callbacks_;
    uint32_t program_counter_;
    int state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debug_2eproto;
};
// -------------------------------------------------------------------

class Function final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:debug.Function) */ {
 public:
  inline Function() : Function(nullptr) {}
  ~Function() override;
  explicit PROTOBUF_CONSTEXPR Function(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Function(const Function& from);
  Function(Function&& from) noexcept
    : Function() {
    *this = ::std::move(from);
  }

  inline Function& operator=(const Function& from) {
    CopyFrom(from);
    return *this;
  }
  inline Function& operator=(Function&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Function& default_instance() {
    return *internal_default_instance();
  }
  static inline const Function* internal_default_instance() {
    return reinterpret_cast<const Function*>(
               &_Function_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Function& a, Function& b) {
    a.Swap(&b);
  }
  inline void Swap(Function* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Function* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Function* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Function>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Function& from);
  void MergeFrom(const Function& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Function* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "debug.Function";
  }
  protected:
  explicit Function(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstructionsFieldNumber = 4,
    kRangeFieldNumber = 2,
    kLocalsFieldNumber = 3,
    kFidxFieldNumber = 1,
  };
  // bytes instructions = 4;
  void clear_instructions();
  const std::string& instructions() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instructions(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instructions();
  PROTOBUF_NODISCARD std::string* release_instructions();
  void set_allocated_instructions(std::string* instructions);
  private:
  const std::string& _internal_instructions() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instructions(const std::string& value);
  std::string* _internal_mutable_instructions();
  public:

  // .debug.Range range = 2;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::debug::Range& range() const;
  PROTOBUF_NODISCARD ::debug::Range* release_range();
  ::debug::Range* mutable_range();
  void set_allocated_range(::debug::Range* range);
  private:
  const ::debug::Range& _internal_range() const;
  ::debug::Range* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::debug::Range* range);
  ::debug::Range* unsafe_arena_release_range();

  // .debug.Locals locals = 3;
  bool has_locals() const;
  private:
  bool _internal_has_locals() const;
  public:
  void clear_locals();
  const ::debug::Locals& locals() const;
  PROTOBUF_NODISCARD ::debug::Locals* release_locals();
  ::debug::Locals* mutable_locals();
  void set_allocated_locals(::debug::Locals* locals);
  private:
  const ::debug::Locals& _internal_locals() const;
  ::debug::Locals* _internal_mutable_locals();
  public:
  void unsafe_arena_set_allocated_locals(
      ::debug::Locals* locals);
  ::debug::Locals* unsafe_arena_release_locals();

  // int32 fidx = 1;
  void clear_fidx();
  int32_t fidx() const;
  void set_fidx(int32_t value);
  private:
  int32_t _internal_fidx() const;
  void _internal_set_fidx(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:debug.Function)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instructions_;
    ::debug::Range* range_;
    ::debug::Locals* locals_;
    int32_t fidx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debug_2eproto;
};
// -------------------------------------------------------------------

class RFC final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:debug.RFC) */ {
 public:
  inline RFC() : RFC(nullptr) {}
  ~RFC() override;
  explicit PROTOBUF_CONSTEXPR RFC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RFC(const RFC& from);
  RFC(RFC&& from) noexcept
    : RFC() {
    *this = ::std::move(from);
  }

  inline RFC& operator=(const RFC& from) {
    CopyFrom(from);
    return *this;
  }
  inline RFC& operator=(RFC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RFC& default_instance() {
    return *internal_default_instance();
  }
  static inline const RFC* internal_default_instance() {
    return reinterpret_cast<const RFC*>(
               &_RFC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RFC& a, RFC& b) {
    a.Swap(&b);
  }
  inline void Swap(RFC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RFC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RFC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RFC>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RFC& from);
  void MergeFrom(const RFC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RFC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "debug.RFC";
  }
  protected:
  explicit RFC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 3,
    kFidxFieldNumber = 1,
    kArgcountFieldNumber = 2,
  };
  // repeated .debug.Value args = 3;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::debug::Value* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Value >*
      mutable_args();
  private:
  const ::debug::Value& _internal_args(int index) const;
  ::debug::Value* _internal_add_args();
  public:
  const ::debug::Value& args(int index) const;
  ::debug::Value* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Value >&
      args() const;

  // int32 fidx = 1;
  void clear_fidx();
  int32_t fidx() const;
  void set_fidx(int32_t value);
  private:
  int32_t _internal_fidx() const;
  void _internal_set_fidx(int32_t value);
  public:

  // int32 argcount = 2;
  void clear_argcount();
  int32_t argcount() const;
  void set_argcount(int32_t value);
  private:
  int32_t _internal_argcount() const;
  void _internal_set_argcount(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:debug.RFC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Value > args_;
    int32_t fidx_;
    int32_t argcount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debug_2eproto;
};
// -------------------------------------------------------------------

class CallstackEntry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:debug.CallstackEntry) */ {
 public:
  inline CallstackEntry() : CallstackEntry(nullptr) {}
  ~CallstackEntry() override;
  explicit PROTOBUF_CONSTEXPR CallstackEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallstackEntry(const CallstackEntry& from);
  CallstackEntry(CallstackEntry&& from) noexcept
    : CallstackEntry() {
    *this = ::std::move(from);
  }

  inline CallstackEntry& operator=(const CallstackEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallstackEntry& operator=(CallstackEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CallstackEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallstackEntry* internal_default_instance() {
    return reinterpret_cast<const CallstackEntry*>(
               &_CallstackEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CallstackEntry& a, CallstackEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(CallstackEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallstackEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallstackEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallstackEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CallstackEntry& from);
  void MergeFrom(const CallstackEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CallstackEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "debug.CallstackEntry";
  }
  protected:
  explicit CallstackEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kFidxFieldNumber = 2,
    kSpFieldNumber = 3,
    kFpFieldNumber = 4,
    kStartFieldNumber = 5,
    kRaFieldNumber = 6,
  };
  // int32 type = 1;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // int32 fidx = 2;
  void clear_fidx();
  int32_t fidx() const;
  void set_fidx(int32_t value);
  private:
  int32_t _internal_fidx() const;
  void _internal_set_fidx(int32_t value);
  public:

  // int32 sp = 3;
  void clear_sp();
  int32_t sp() const;
  void set_sp(int32_t value);
  private:
  int32_t _internal_sp() const;
  void _internal_set_sp(int32_t value);
  public:

  // int32 fp = 4;
  void clear_fp();
  int32_t fp() const;
  void set_fp(int32_t value);
  private:
  int32_t _internal_fp() const;
  void _internal_set_fp(int32_t value);
  public:

  // int32 start = 5;
  void clear_start();
  int32_t start() const;
  void set_start(int32_t value);
  private:
  int32_t _internal_start() const;
  void _internal_set_start(int32_t value);
  public:

  // int32 ra = 6;
  void clear_ra();
  int32_t ra() const;
  void set_ra(int32_t value);
  private:
  int32_t _internal_ra() const;
  void _internal_set_ra(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:debug.CallstackEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t type_;
    int32_t fidx_;
    int32_t sp_;
    int32_t fp_;
    int32_t start_;
    int32_t ra_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debug_2eproto;
};
// -------------------------------------------------------------------

class Locals final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:debug.Locals) */ {
 public:
  inline Locals() : Locals(nullptr) {}
  ~Locals() override;
  explicit PROTOBUF_CONSTEXPR Locals(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Locals(const Locals& from);
  Locals(Locals&& from) noexcept
    : Locals() {
    *this = ::std::move(from);
  }

  inline Locals& operator=(const Locals& from) {
    CopyFrom(from);
    return *this;
  }
  inline Locals& operator=(Locals&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Locals& default_instance() {
    return *internal_default_instance();
  }
  static inline const Locals* internal_default_instance() {
    return reinterpret_cast<const Locals*>(
               &_Locals_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Locals& a, Locals& b) {
    a.Swap(&b);
  }
  inline void Swap(Locals* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Locals* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Locals* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Locals>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Locals& from);
  void MergeFrom(const Locals& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Locals* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "debug.Locals";
  }
  protected:
  explicit Locals(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kCountFieldNumber = 1,
  };
  // repeated .debug.Value values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::debug::Value* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Value >*
      mutable_values();
  private:
  const ::debug::Value& _internal_values(int index) const;
  ::debug::Value* _internal_add_values();
  public:
  const ::debug::Value& values(int index) const;
  ::debug::Value* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Value >&
      values() const;

  // int32 count = 1;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:debug.Locals)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Value > values_;
    int32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debug_2eproto;
};
// -------------------------------------------------------------------

class Value final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:debug.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() override;
  explicit PROTOBUF_CONSTEXPR Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Value& default_instance() {
    return *internal_default_instance();
  }
  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Value* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "debug.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Value_Type Type;
  static constexpr Type i32 =
    Value_Type_i32;
  static constexpr Type i64 =
    Value_Type_i64;
  static constexpr Type f32 =
    Value_Type_f32;
  static constexpr Type f64 =
    Value_Type_f64;
  static constexpr Type any =
    Value_Type_any;
  static inline bool Type_IsValid(int value) {
    return Value_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Value_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Value_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Value_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Value_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Value_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kTypeFieldNumber = 1,
    kIndexFieldNumber = 3,
  };
  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .debug.Value.Type type = 1;
  void clear_type();
  ::debug::Value_Type type() const;
  void set_type(::debug::Value_Type value);
  private:
  ::debug::Value_Type _internal_type() const;
  void _internal_set_type(::debug::Value_Type value);
  public:

  // int32 index = 3;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:debug.Value)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    int type_;
    int32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debug_2eproto;
};
// -------------------------------------------------------------------

class CallbackMapping final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:debug.CallbackMapping) */ {
 public:
  inline CallbackMapping() : CallbackMapping(nullptr) {}
  ~CallbackMapping() override;
  explicit PROTOBUF_CONSTEXPR CallbackMapping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallbackMapping(const CallbackMapping& from);
  CallbackMapping(CallbackMapping&& from) noexcept
    : CallbackMapping() {
    *this = ::std::move(from);
  }

  inline CallbackMapping& operator=(const CallbackMapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallbackMapping& operator=(CallbackMapping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CallbackMapping& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallbackMapping* internal_default_instance() {
    return reinterpret_cast<const CallbackMapping*>(
               &_CallbackMapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CallbackMapping& a, CallbackMapping& b) {
    a.Swap(&b);
  }
  inline void Swap(CallbackMapping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallbackMapping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallbackMapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallbackMapping>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CallbackMapping& from);
  void MergeFrom(const CallbackMapping& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CallbackMapping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "debug.CallbackMapping";
  }
  protected:
  explicit CallbackMapping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .debug.CallbackEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::debug::CallbackEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::CallbackEntry >*
      mutable_entries();
  private:
  const ::debug::CallbackEntry& _internal_entries(int index) const;
  ::debug::CallbackEntry* _internal_add_entries();
  public:
  const ::debug::CallbackEntry& entries(int index) const;
  ::debug::CallbackEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::CallbackEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:debug.CallbackMapping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::CallbackEntry > entries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debug_2eproto;
};
// -------------------------------------------------------------------

class CallbackEntry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:debug.CallbackEntry) */ {
 public:
  inline CallbackEntry() : CallbackEntry(nullptr) {}
  ~CallbackEntry() override;
  explicit PROTOBUF_CONSTEXPR CallbackEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallbackEntry(const CallbackEntry& from);
  CallbackEntry(CallbackEntry&& from) noexcept
    : CallbackEntry() {
    *this = ::std::move(from);
  }

  inline CallbackEntry& operator=(const CallbackEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallbackEntry& operator=(CallbackEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CallbackEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallbackEntry* internal_default_instance() {
    return reinterpret_cast<const CallbackEntry*>(
               &_CallbackEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CallbackEntry& a, CallbackEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(CallbackEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallbackEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallbackEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallbackEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CallbackEntry& from);
  void MergeFrom(const CallbackEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CallbackEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "debug.CallbackEntry";
  }
  protected:
  explicit CallbackEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTidxFieldNumber = 2,
    kTopicFieldNumber = 1,
  };
  // repeated int32 tidx = 2;
  int tidx_size() const;
  private:
  int _internal_tidx_size() const;
  public:
  void clear_tidx();
  private:
  int32_t _internal_tidx(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_tidx() const;
  void _internal_add_tidx(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_tidx();
  public:
  int32_t tidx(int index) const;
  void set_tidx(int index, int32_t value);
  void add_tidx(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      tidx() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_tidx();

  // string topic = 1;
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // @@protoc_insertion_point(class_scope:debug.CallbackEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > tidx_;
    mutable std::atomic<int> _tidx_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debug_2eproto;
};
// -------------------------------------------------------------------

class EventsQueue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:debug.EventsQueue) */ {
 public:
  inline EventsQueue() : EventsQueue(nullptr) {}
  ~EventsQueue() override;
  explicit PROTOBUF_CONSTEXPR EventsQueue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventsQueue(const EventsQueue& from);
  EventsQueue(EventsQueue&& from) noexcept
    : EventsQueue() {
    *this = ::std::move(from);
  }

  inline EventsQueue& operator=(const EventsQueue& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventsQueue& operator=(EventsQueue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const EventsQueue& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventsQueue* internal_default_instance() {
    return reinterpret_cast<const EventsQueue*>(
               &_EventsQueue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EventsQueue& a, EventsQueue& b) {
    a.Swap(&b);
  }
  inline void Swap(EventsQueue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventsQueue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventsQueue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventsQueue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EventsQueue& from);
  void MergeFrom(const EventsQueue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EventsQueue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "debug.EventsQueue";
  }
  protected:
  explicit EventsQueue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 2,
    kRangeFieldNumber = 3,
    kCountFieldNumber = 1,
  };
  // repeated .debug.Event events = 2;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::debug::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Event >*
      mutable_events();
  private:
  const ::debug::Event& _internal_events(int index) const;
  ::debug::Event* _internal_add_events();
  public:
  const ::debug::Event& events(int index) const;
  ::debug::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Event >&
      events() const;

  // optional .debug.Range range = 3;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::debug::Range& range() const;
  PROTOBUF_NODISCARD ::debug::Range* release_range();
  ::debug::Range* mutable_range();
  void set_allocated_range(::debug::Range* range);
  private:
  const ::debug::Range& _internal_range() const;
  ::debug::Range* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::debug::Range* range);
  ::debug::Range* unsafe_arena_release_range();

  // int32 count = 1;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:debug.EventsQueue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Event > events_;
    ::debug::Range* range_;
    int32_t count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debug_2eproto;
};
// -------------------------------------------------------------------

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:debug.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit PROTOBUF_CONSTEXPR Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "debug.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kPayloadFieldNumber = 2,
  };
  // string topic = 1;
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // string payload = 2;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:debug.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debug_2eproto;
};
// -------------------------------------------------------------------

class Range final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:debug.Range) */ {
 public:
  inline Range() : Range(nullptr) {}
  ~Range() override;
  explicit PROTOBUF_CONSTEXPR Range(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Range(const Range& from);
  Range(Range&& from) noexcept
    : Range() {
    *this = ::std::move(from);
  }

  inline Range& operator=(const Range& from) {
    CopyFrom(from);
    return *this;
  }
  inline Range& operator=(Range&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Range& default_instance() {
    return *internal_default_instance();
  }
  static inline const Range* internal_default_instance() {
    return reinterpret_cast<const Range*>(
               &_Range_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Range& a, Range& b) {
    a.Swap(&b);
  }
  inline void Swap(Range* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Range* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Range* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Range>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Range& from);
  void MergeFrom(const Range& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Range* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "debug.Range";
  }
  protected:
  explicit Range(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // int32 start = 1;
  void clear_start();
  int32_t start() const;
  void set_start(int32_t value);
  private:
  int32_t _internal_start() const;
  void _internal_set_start(int32_t value);
  public:

  // int32 end = 2;
  void clear_end();
  int32_t end() const;
  void set_end(int32_t value);
  private:
  int32_t _internal_end() const;
  void _internal_set_end(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:debug.Range)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t start_;
    int32_t end_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debug_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DebugMessage

// .debug.Command command = 1;
inline void DebugMessage::clear_command() {
  _impl_.command_ = 0;
}
inline ::debug::Command DebugMessage::_internal_command() const {
  return static_cast< ::debug::Command >(_impl_.command_);
}
inline ::debug::Command DebugMessage::command() const {
  // @@protoc_insertion_point(field_get:debug.DebugMessage.command)
  return _internal_command();
}
inline void DebugMessage::_internal_set_command(::debug::Command value) {
  
  _impl_.command_ = value;
}
inline void DebugMessage::set_command(::debug::Command value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:debug.DebugMessage.command)
}

// optional .debug.Payload payload = 2;
inline bool DebugMessage::_internal_has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_ != nullptr);
  return value;
}
inline bool DebugMessage::has_payload() const {
  return _internal_has_payload();
}
inline void DebugMessage::clear_payload() {
  if (_impl_.payload_ != nullptr) _impl_.payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::debug::Payload& DebugMessage::_internal_payload() const {
  const ::debug::Payload* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::debug::Payload&>(
      ::debug::_Payload_default_instance_);
}
inline const ::debug::Payload& DebugMessage::payload() const {
  // @@protoc_insertion_point(field_get:debug.DebugMessage.payload)
  return _internal_payload();
}
inline void DebugMessage::unsafe_arena_set_allocated_payload(
    ::debug::Payload* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = payload;
  if (payload) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debug.DebugMessage.payload)
}
inline ::debug::Payload* DebugMessage::release_payload() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::debug::Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::debug::Payload* DebugMessage::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:debug.DebugMessage.payload)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::debug::Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::debug::Payload* DebugMessage::_internal_mutable_payload() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::debug::Payload>(GetArenaForAllocation());
    _impl_.payload_ = p;
  }
  return _impl_.payload_;
}
inline ::debug::Payload* DebugMessage::mutable_payload() {
  ::debug::Payload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:debug.DebugMessage.payload)
  return _msg;
}
inline void DebugMessage::set_allocated_payload(::debug::Payload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:debug.DebugMessage.payload)
}

// -------------------------------------------------------------------

// Notification

// .debug.Notification.Type type = 1;
inline void Notification::clear_type() {
  _impl_.type_ = 0;
}
inline ::debug::Notification_Type Notification::_internal_type() const {
  return static_cast< ::debug::Notification_Type >(_impl_.type_);
}
inline ::debug::Notification_Type Notification::type() const {
  // @@protoc_insertion_point(field_get:debug.Notification.type)
  return _internal_type();
}
inline void Notification::_internal_set_type(::debug::Notification_Type value) {
  
  _impl_.type_ = value;
}
inline void Notification::set_type(::debug::Notification_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:debug.Notification.type)
}

// optional .debug.Payload payload = 2;
inline bool Notification::_internal_has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_ != nullptr);
  return value;
}
inline bool Notification::has_payload() const {
  return _internal_has_payload();
}
inline void Notification::clear_payload() {
  if (_impl_.payload_ != nullptr) _impl_.payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::debug::Payload& Notification::_internal_payload() const {
  const ::debug::Payload* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::debug::Payload&>(
      ::debug::_Payload_default_instance_);
}
inline const ::debug::Payload& Notification::payload() const {
  // @@protoc_insertion_point(field_get:debug.Notification.payload)
  return _internal_payload();
}
inline void Notification::unsafe_arena_set_allocated_payload(
    ::debug::Payload* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = payload;
  if (payload) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debug.Notification.payload)
}
inline ::debug::Payload* Notification::release_payload() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::debug::Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::debug::Payload* Notification::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:debug.Notification.payload)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::debug::Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::debug::Payload* Notification::_internal_mutable_payload() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::debug::Payload>(GetArenaForAllocation());
    _impl_.payload_ = p;
  }
  return _impl_.payload_;
}
inline ::debug::Payload* Notification::mutable_payload() {
  ::debug::Payload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:debug.Notification.payload)
  return _msg;
}
inline void Notification::set_allocated_payload(::debug::Payload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:debug.Notification.payload)
}

// -------------------------------------------------------------------

// Payload

// .debug.Snapshot snapshot = 1;
inline bool Payload::_internal_has_snapshot() const {
  return payload_case() == kSnapshot;
}
inline bool Payload::has_snapshot() const {
  return _internal_has_snapshot();
}
inline void Payload::set_has_snapshot() {
  _impl_._oneof_case_[0] = kSnapshot;
}
inline void Payload::clear_snapshot() {
  if (_internal_has_snapshot()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.snapshot_;
    }
    clear_has_payload();
  }
}
inline ::debug::Snapshot* Payload::release_snapshot() {
  // @@protoc_insertion_point(field_release:debug.Payload.snapshot)
  if (_internal_has_snapshot()) {
    clear_has_payload();
    ::debug::Snapshot* temp = _impl_.payload_.snapshot_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debug::Snapshot& Payload::_internal_snapshot() const {
  return _internal_has_snapshot()
      ? *_impl_.payload_.snapshot_
      : reinterpret_cast< ::debug::Snapshot&>(::debug::_Snapshot_default_instance_);
}
inline const ::debug::Snapshot& Payload::snapshot() const {
  // @@protoc_insertion_point(field_get:debug.Payload.snapshot)
  return _internal_snapshot();
}
inline ::debug::Snapshot* Payload::unsafe_arena_release_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debug.Payload.snapshot)
  if (_internal_has_snapshot()) {
    clear_has_payload();
    ::debug::Snapshot* temp = _impl_.payload_.snapshot_;
    _impl_.payload_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Payload::unsafe_arena_set_allocated_snapshot(::debug::Snapshot* snapshot) {
  clear_payload();
  if (snapshot) {
    set_has_snapshot();
    _impl_.payload_.snapshot_ = snapshot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debug.Payload.snapshot)
}
inline ::debug::Snapshot* Payload::_internal_mutable_snapshot() {
  if (!_internal_has_snapshot()) {
    clear_payload();
    set_has_snapshot();
    _impl_.payload_.snapshot_ = CreateMaybeMessage< ::debug::Snapshot >(GetArenaForAllocation());
  }
  return _impl_.payload_.snapshot_;
}
inline ::debug::Snapshot* Payload::mutable_snapshot() {
  ::debug::Snapshot* _msg = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:debug.Payload.snapshot)
  return _msg;
}

// .debug.Locals locals = 2;
inline bool Payload::_internal_has_locals() const {
  return payload_case() == kLocals;
}
inline bool Payload::has_locals() const {
  return _internal_has_locals();
}
inline void Payload::set_has_locals() {
  _impl_._oneof_case_[0] = kLocals;
}
inline void Payload::clear_locals() {
  if (_internal_has_locals()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.locals_;
    }
    clear_has_payload();
  }
}
inline ::debug::Locals* Payload::release_locals() {
  // @@protoc_insertion_point(field_release:debug.Payload.locals)
  if (_internal_has_locals()) {
    clear_has_payload();
    ::debug::Locals* temp = _impl_.payload_.locals_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.locals_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debug::Locals& Payload::_internal_locals() const {
  return _internal_has_locals()
      ? *_impl_.payload_.locals_
      : reinterpret_cast< ::debug::Locals&>(::debug::_Locals_default_instance_);
}
inline const ::debug::Locals& Payload::locals() const {
  // @@protoc_insertion_point(field_get:debug.Payload.locals)
  return _internal_locals();
}
inline ::debug::Locals* Payload::unsafe_arena_release_locals() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debug.Payload.locals)
  if (_internal_has_locals()) {
    clear_has_payload();
    ::debug::Locals* temp = _impl_.payload_.locals_;
    _impl_.payload_.locals_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Payload::unsafe_arena_set_allocated_locals(::debug::Locals* locals) {
  clear_payload();
  if (locals) {
    set_has_locals();
    _impl_.payload_.locals_ = locals;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debug.Payload.locals)
}
inline ::debug::Locals* Payload::_internal_mutable_locals() {
  if (!_internal_has_locals()) {
    clear_payload();
    set_has_locals();
    _impl_.payload_.locals_ = CreateMaybeMessage< ::debug::Locals >(GetArenaForAllocation());
  }
  return _impl_.payload_.locals_;
}
inline ::debug::Locals* Payload::mutable_locals() {
  ::debug::Locals* _msg = _internal_mutable_locals();
  // @@protoc_insertion_point(field_mutable:debug.Payload.locals)
  return _msg;
}

// .debug.Function function = 3;
inline bool Payload::_internal_has_function() const {
  return payload_case() == kFunction;
}
inline bool Payload::has_function() const {
  return _internal_has_function();
}
inline void Payload::set_has_function() {
  _impl_._oneof_case_[0] = kFunction;
}
inline void Payload::clear_function() {
  if (_internal_has_function()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.function_;
    }
    clear_has_payload();
  }
}
inline ::debug::Function* Payload::release_function() {
  // @@protoc_insertion_point(field_release:debug.Payload.function)
  if (_internal_has_function()) {
    clear_has_payload();
    ::debug::Function* temp = _impl_.payload_.function_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debug::Function& Payload::_internal_function() const {
  return _internal_has_function()
      ? *_impl_.payload_.function_
      : reinterpret_cast< ::debug::Function&>(::debug::_Function_default_instance_);
}
inline const ::debug::Function& Payload::function() const {
  // @@protoc_insertion_point(field_get:debug.Payload.function)
  return _internal_function();
}
inline ::debug::Function* Payload::unsafe_arena_release_function() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debug.Payload.function)
  if (_internal_has_function()) {
    clear_has_payload();
    ::debug::Function* temp = _impl_.payload_.function_;
    _impl_.payload_.function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Payload::unsafe_arena_set_allocated_function(::debug::Function* function) {
  clear_payload();
  if (function) {
    set_has_function();
    _impl_.payload_.function_ = function;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debug.Payload.function)
}
inline ::debug::Function* Payload::_internal_mutable_function() {
  if (!_internal_has_function()) {
    clear_payload();
    set_has_function();
    _impl_.payload_.function_ = CreateMaybeMessage< ::debug::Function >(GetArenaForAllocation());
  }
  return _impl_.payload_.function_;
}
inline ::debug::Function* Payload::mutable_function() {
  ::debug::Function* _msg = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:debug.Payload.function)
  return _msg;
}

// string breakpoint = 4;
inline bool Payload::_internal_has_breakpoint() const {
  return payload_case() == kBreakpoint;
}
inline bool Payload::has_breakpoint() const {
  return _internal_has_breakpoint();
}
inline void Payload::set_has_breakpoint() {
  _impl_._oneof_case_[0] = kBreakpoint;
}
inline void Payload::clear_breakpoint() {
  if (_internal_has_breakpoint()) {
    _impl_.payload_.breakpoint_.Destroy();
    clear_has_payload();
  }
}
inline const std::string& Payload::breakpoint() const {
  // @@protoc_insertion_point(field_get:debug.Payload.breakpoint)
  return _internal_breakpoint();
}
template <typename ArgT0, typename... ArgT>
inline void Payload::set_breakpoint(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_breakpoint()) {
    clear_payload();
    set_has_breakpoint();
    _impl_.payload_.breakpoint_.InitDefault();
  }
  _impl_.payload_.breakpoint_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:debug.Payload.breakpoint)
}
inline std::string* Payload::mutable_breakpoint() {
  std::string* _s = _internal_mutable_breakpoint();
  // @@protoc_insertion_point(field_mutable:debug.Payload.breakpoint)
  return _s;
}
inline const std::string& Payload::_internal_breakpoint() const {
  if (_internal_has_breakpoint()) {
    return _impl_.payload_.breakpoint_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Payload::_internal_set_breakpoint(const std::string& value) {
  if (!_internal_has_breakpoint()) {
    clear_payload();
    set_has_breakpoint();
    _impl_.payload_.breakpoint_.InitDefault();
  }
  _impl_.payload_.breakpoint_.Set(value, GetArenaForAllocation());
}
inline std::string* Payload::_internal_mutable_breakpoint() {
  if (!_internal_has_breakpoint()) {
    clear_payload();
    set_has_breakpoint();
    _impl_.payload_.breakpoint_.InitDefault();
  }
  return _impl_.payload_.breakpoint_.Mutable(      GetArenaForAllocation());
}
inline std::string* Payload::release_breakpoint() {
  // @@protoc_insertion_point(field_release:debug.Payload.breakpoint)
  if (_internal_has_breakpoint()) {
    clear_has_payload();
    return _impl_.payload_.breakpoint_.Release();
  } else {
    return nullptr;
  }
}
inline void Payload::set_allocated_breakpoint(std::string* breakpoint) {
  if (has_payload()) {
    clear_payload();
  }
  if (breakpoint != nullptr) {
    set_has_breakpoint();
    _impl_.payload_.breakpoint_.InitAllocated(breakpoint, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:debug.Payload.breakpoint)
}

// .debug.EventsQueue queue = 5;
inline bool Payload::_internal_has_queue() const {
  return payload_case() == kQueue;
}
inline bool Payload::has_queue() const {
  return _internal_has_queue();
}
inline void Payload::set_has_queue() {
  _impl_._oneof_case_[0] = kQueue;
}
inline void Payload::clear_queue() {
  if (_internal_has_queue()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.queue_;
    }
    clear_has_payload();
  }
}
inline ::debug::EventsQueue* Payload::release_queue() {
  // @@protoc_insertion_point(field_release:debug.Payload.queue)
  if (_internal_has_queue()) {
    clear_has_payload();
    ::debug::EventsQueue* temp = _impl_.payload_.queue_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.queue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debug::EventsQueue& Payload::_internal_queue() const {
  return _internal_has_queue()
      ? *_impl_.payload_.queue_
      : reinterpret_cast< ::debug::EventsQueue&>(::debug::_EventsQueue_default_instance_);
}
inline const ::debug::EventsQueue& Payload::queue() const {
  // @@protoc_insertion_point(field_get:debug.Payload.queue)
  return _internal_queue();
}
inline ::debug::EventsQueue* Payload::unsafe_arena_release_queue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debug.Payload.queue)
  if (_internal_has_queue()) {
    clear_has_payload();
    ::debug::EventsQueue* temp = _impl_.payload_.queue_;
    _impl_.payload_.queue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Payload::unsafe_arena_set_allocated_queue(::debug::EventsQueue* queue) {
  clear_payload();
  if (queue) {
    set_has_queue();
    _impl_.payload_.queue_ = queue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debug.Payload.queue)
}
inline ::debug::EventsQueue* Payload::_internal_mutable_queue() {
  if (!_internal_has_queue()) {
    clear_payload();
    set_has_queue();
    _impl_.payload_.queue_ = CreateMaybeMessage< ::debug::EventsQueue >(GetArenaForAllocation());
  }
  return _impl_.payload_.queue_;
}
inline ::debug::EventsQueue* Payload::mutable_queue() {
  ::debug::EventsQueue* _msg = _internal_mutable_queue();
  // @@protoc_insertion_point(field_mutable:debug.Payload.queue)
  return _msg;
}

// .debug.Event event = 6;
inline bool Payload::_internal_has_event() const {
  return payload_case() == kEvent;
}
inline bool Payload::has_event() const {
  return _internal_has_event();
}
inline void Payload::set_has_event() {
  _impl_._oneof_case_[0] = kEvent;
}
inline void Payload::clear_event() {
  if (_internal_has_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.event_;
    }
    clear_has_payload();
  }
}
inline ::debug::Event* Payload::release_event() {
  // @@protoc_insertion_point(field_release:debug.Payload.event)
  if (_internal_has_event()) {
    clear_has_payload();
    ::debug::Event* temp = _impl_.payload_.event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debug::Event& Payload::_internal_event() const {
  return _internal_has_event()
      ? *_impl_.payload_.event_
      : reinterpret_cast< ::debug::Event&>(::debug::_Event_default_instance_);
}
inline const ::debug::Event& Payload::event() const {
  // @@protoc_insertion_point(field_get:debug.Payload.event)
  return _internal_event();
}
inline ::debug::Event* Payload::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debug.Payload.event)
  if (_internal_has_event()) {
    clear_has_payload();
    ::debug::Event* temp = _impl_.payload_.event_;
    _impl_.payload_.event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Payload::unsafe_arena_set_allocated_event(::debug::Event* event) {
  clear_payload();
  if (event) {
    set_has_event();
    _impl_.payload_.event_ = event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debug.Payload.event)
}
inline ::debug::Event* Payload::_internal_mutable_event() {
  if (!_internal_has_event()) {
    clear_payload();
    set_has_event();
    _impl_.payload_.event_ = CreateMaybeMessage< ::debug::Event >(GetArenaForAllocation());
  }
  return _impl_.payload_.event_;
}
inline ::debug::Event* Payload::mutable_event() {
  ::debug::Event* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:debug.Payload.event)
  return _msg;
}

// .debug.Range range = 7;
inline bool Payload::_internal_has_range() const {
  return payload_case() == kRange;
}
inline bool Payload::has_range() const {
  return _internal_has_range();
}
inline void Payload::set_has_range() {
  _impl_._oneof_case_[0] = kRange;
}
inline void Payload::clear_range() {
  if (_internal_has_range()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.range_;
    }
    clear_has_payload();
  }
}
inline ::debug::Range* Payload::release_range() {
  // @@protoc_insertion_point(field_release:debug.Payload.range)
  if (_internal_has_range()) {
    clear_has_payload();
    ::debug::Range* temp = _impl_.payload_.range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debug::Range& Payload::_internal_range() const {
  return _internal_has_range()
      ? *_impl_.payload_.range_
      : reinterpret_cast< ::debug::Range&>(::debug::_Range_default_instance_);
}
inline const ::debug::Range& Payload::range() const {
  // @@protoc_insertion_point(field_get:debug.Payload.range)
  return _internal_range();
}
inline ::debug::Range* Payload::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debug.Payload.range)
  if (_internal_has_range()) {
    clear_has_payload();
    ::debug::Range* temp = _impl_.payload_.range_;
    _impl_.payload_.range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Payload::unsafe_arena_set_allocated_range(::debug::Range* range) {
  clear_payload();
  if (range) {
    set_has_range();
    _impl_.payload_.range_ = range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debug.Payload.range)
}
inline ::debug::Range* Payload::_internal_mutable_range() {
  if (!_internal_has_range()) {
    clear_payload();
    set_has_range();
    _impl_.payload_.range_ = CreateMaybeMessage< ::debug::Range >(GetArenaForAllocation());
  }
  return _impl_.payload_.range_;
}
inline ::debug::Range* Payload::mutable_range() {
  ::debug::Range* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:debug.Payload.range)
  return _msg;
}

// .debug.CallbackMapping callbacks = 8;
inline bool Payload::_internal_has_callbacks() const {
  return payload_case() == kCallbacks;
}
inline bool Payload::has_callbacks() const {
  return _internal_has_callbacks();
}
inline void Payload::set_has_callbacks() {
  _impl_._oneof_case_[0] = kCallbacks;
}
inline void Payload::clear_callbacks() {
  if (_internal_has_callbacks()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.callbacks_;
    }
    clear_has_payload();
  }
}
inline ::debug::CallbackMapping* Payload::release_callbacks() {
  // @@protoc_insertion_point(field_release:debug.Payload.callbacks)
  if (_internal_has_callbacks()) {
    clear_has_payload();
    ::debug::CallbackMapping* temp = _impl_.payload_.callbacks_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.callbacks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debug::CallbackMapping& Payload::_internal_callbacks() const {
  return _internal_has_callbacks()
      ? *_impl_.payload_.callbacks_
      : reinterpret_cast< ::debug::CallbackMapping&>(::debug::_CallbackMapping_default_instance_);
}
inline const ::debug::CallbackMapping& Payload::callbacks() const {
  // @@protoc_insertion_point(field_get:debug.Payload.callbacks)
  return _internal_callbacks();
}
inline ::debug::CallbackMapping* Payload::unsafe_arena_release_callbacks() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debug.Payload.callbacks)
  if (_internal_has_callbacks()) {
    clear_has_payload();
    ::debug::CallbackMapping* temp = _impl_.payload_.callbacks_;
    _impl_.payload_.callbacks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Payload::unsafe_arena_set_allocated_callbacks(::debug::CallbackMapping* callbacks) {
  clear_payload();
  if (callbacks) {
    set_has_callbacks();
    _impl_.payload_.callbacks_ = callbacks;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debug.Payload.callbacks)
}
inline ::debug::CallbackMapping* Payload::_internal_mutable_callbacks() {
  if (!_internal_has_callbacks()) {
    clear_payload();
    set_has_callbacks();
    _impl_.payload_.callbacks_ = CreateMaybeMessage< ::debug::CallbackMapping >(GetArenaForAllocation());
  }
  return _impl_.payload_.callbacks_;
}
inline ::debug::CallbackMapping* Payload::mutable_callbacks() {
  ::debug::CallbackMapping* _msg = _internal_mutable_callbacks();
  // @@protoc_insertion_point(field_mutable:debug.Payload.callbacks)
  return _msg;
}

// .debug.RFC call = 9;
inline bool Payload::_internal_has_call() const {
  return payload_case() == kCall;
}
inline bool Payload::has_call() const {
  return _internal_has_call();
}
inline void Payload::set_has_call() {
  _impl_._oneof_case_[0] = kCall;
}
inline void Payload::clear_call() {
  if (_internal_has_call()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.call_;
    }
    clear_has_payload();
  }
}
inline ::debug::RFC* Payload::release_call() {
  // @@protoc_insertion_point(field_release:debug.Payload.call)
  if (_internal_has_call()) {
    clear_has_payload();
    ::debug::RFC* temp = _impl_.payload_.call_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debug::RFC& Payload::_internal_call() const {
  return _internal_has_call()
      ? *_impl_.payload_.call_
      : reinterpret_cast< ::debug::RFC&>(::debug::_RFC_default_instance_);
}
inline const ::debug::RFC& Payload::call() const {
  // @@protoc_insertion_point(field_get:debug.Payload.call)
  return _internal_call();
}
inline ::debug::RFC* Payload::unsafe_arena_release_call() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debug.Payload.call)
  if (_internal_has_call()) {
    clear_has_payload();
    ::debug::RFC* temp = _impl_.payload_.call_;
    _impl_.payload_.call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Payload::unsafe_arena_set_allocated_call(::debug::RFC* call) {
  clear_payload();
  if (call) {
    set_has_call();
    _impl_.payload_.call_ = call;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debug.Payload.call)
}
inline ::debug::RFC* Payload::_internal_mutable_call() {
  if (!_internal_has_call()) {
    clear_payload();
    set_has_call();
    _impl_.payload_.call_ = CreateMaybeMessage< ::debug::RFC >(GetArenaForAllocation());
  }
  return _impl_.payload_.call_;
}
inline ::debug::RFC* Payload::mutable_call() {
  ::debug::RFC* _msg = _internal_mutable_call();
  // @@protoc_insertion_point(field_mutable:debug.Payload.call)
  return _msg;
}

inline bool Payload::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Payload::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Payload::PayloadCase Payload::payload_case() const {
  return Payload::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Snapshot

// uint32 program_counter = 1;
inline void Snapshot::clear_program_counter() {
  _impl_.program_counter_ = 0u;
}
inline uint32_t Snapshot::_internal_program_counter() const {
  return _impl_.program_counter_;
}
inline uint32_t Snapshot::program_counter() const {
  // @@protoc_insertion_point(field_get:debug.Snapshot.program_counter)
  return _internal_program_counter();
}
inline void Snapshot::_internal_set_program_counter(uint32_t value) {
  
  _impl_.program_counter_ = value;
}
inline void Snapshot::set_program_counter(uint32_t value) {
  _internal_set_program_counter(value);
  // @@protoc_insertion_point(field_set:debug.Snapshot.program_counter)
}

// .debug.State state = 2;
inline void Snapshot::clear_state() {
  _impl_.state_ = 0;
}
inline ::debug::State Snapshot::_internal_state() const {
  return static_cast< ::debug::State >(_impl_.state_);
}
inline ::debug::State Snapshot::state() const {
  // @@protoc_insertion_point(field_get:debug.Snapshot.state)
  return _internal_state();
}
inline void Snapshot::_internal_set_state(::debug::State value) {
  
  _impl_.state_ = value;
}
inline void Snapshot::set_state(::debug::State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:debug.Snapshot.state)
}

// repeated string breakpoints = 3;
inline int Snapshot::_internal_breakpoints_size() const {
  return _impl_.breakpoints_.size();
}
inline int Snapshot::breakpoints_size() const {
  return _internal_breakpoints_size();
}
inline void Snapshot::clear_breakpoints() {
  _impl_.breakpoints_.Clear();
}
inline std::string* Snapshot::add_breakpoints() {
  std::string* _s = _internal_add_breakpoints();
  // @@protoc_insertion_point(field_add_mutable:debug.Snapshot.breakpoints)
  return _s;
}
inline const std::string& Snapshot::_internal_breakpoints(int index) const {
  return _impl_.breakpoints_.Get(index);
}
inline const std::string& Snapshot::breakpoints(int index) const {
  // @@protoc_insertion_point(field_get:debug.Snapshot.breakpoints)
  return _internal_breakpoints(index);
}
inline std::string* Snapshot::mutable_breakpoints(int index) {
  // @@protoc_insertion_point(field_mutable:debug.Snapshot.breakpoints)
  return _impl_.breakpoints_.Mutable(index);
}
inline void Snapshot::set_breakpoints(int index, const std::string& value) {
  _impl_.breakpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:debug.Snapshot.breakpoints)
}
inline void Snapshot::set_breakpoints(int index, std::string&& value) {
  _impl_.breakpoints_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:debug.Snapshot.breakpoints)
}
inline void Snapshot::set_breakpoints(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.breakpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:debug.Snapshot.breakpoints)
}
inline void Snapshot::set_breakpoints(int index, const char* value, size_t size) {
  _impl_.breakpoints_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:debug.Snapshot.breakpoints)
}
inline std::string* Snapshot::_internal_add_breakpoints() {
  return _impl_.breakpoints_.Add();
}
inline void Snapshot::add_breakpoints(const std::string& value) {
  _impl_.breakpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:debug.Snapshot.breakpoints)
}
inline void Snapshot::add_breakpoints(std::string&& value) {
  _impl_.breakpoints_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:debug.Snapshot.breakpoints)
}
inline void Snapshot::add_breakpoints(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.breakpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:debug.Snapshot.breakpoints)
}
inline void Snapshot::add_breakpoints(const char* value, size_t size) {
  _impl_.breakpoints_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:debug.Snapshot.breakpoints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Snapshot::breakpoints() const {
  // @@protoc_insertion_point(field_list:debug.Snapshot.breakpoints)
  return _impl_.breakpoints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Snapshot::mutable_breakpoints() {
  // @@protoc_insertion_point(field_mutable_list:debug.Snapshot.breakpoints)
  return &_impl_.breakpoints_;
}

// repeated .debug.Function functions = 4;
inline int Snapshot::_internal_functions_size() const {
  return _impl_.functions_.size();
}
inline int Snapshot::functions_size() const {
  return _internal_functions_size();
}
inline void Snapshot::clear_functions() {
  _impl_.functions_.Clear();
}
inline ::debug::Function* Snapshot::mutable_functions(int index) {
  // @@protoc_insertion_point(field_mutable:debug.Snapshot.functions)
  return _impl_.functions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Function >*
Snapshot::mutable_functions() {
  // @@protoc_insertion_point(field_mutable_list:debug.Snapshot.functions)
  return &_impl_.functions_;
}
inline const ::debug::Function& Snapshot::_internal_functions(int index) const {
  return _impl_.functions_.Get(index);
}
inline const ::debug::Function& Snapshot::functions(int index) const {
  // @@protoc_insertion_point(field_get:debug.Snapshot.functions)
  return _internal_functions(index);
}
inline ::debug::Function* Snapshot::_internal_add_functions() {
  return _impl_.functions_.Add();
}
inline ::debug::Function* Snapshot::add_functions() {
  ::debug::Function* _add = _internal_add_functions();
  // @@protoc_insertion_point(field_add:debug.Snapshot.functions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Function >&
Snapshot::functions() const {
  // @@protoc_insertion_point(field_list:debug.Snapshot.functions)
  return _impl_.functions_;
}

// repeated .debug.CallstackEntry callstack = 5;
inline int Snapshot::_internal_callstack_size() const {
  return _impl_.callstack_.size();
}
inline int Snapshot::callstack_size() const {
  return _internal_callstack_size();
}
inline void Snapshot::clear_callstack() {
  _impl_.callstack_.Clear();
}
inline ::debug::CallstackEntry* Snapshot::mutable_callstack(int index) {
  // @@protoc_insertion_point(field_mutable:debug.Snapshot.callstack)
  return _impl_.callstack_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::CallstackEntry >*
Snapshot::mutable_callstack() {
  // @@protoc_insertion_point(field_mutable_list:debug.Snapshot.callstack)
  return &_impl_.callstack_;
}
inline const ::debug::CallstackEntry& Snapshot::_internal_callstack(int index) const {
  return _impl_.callstack_.Get(index);
}
inline const ::debug::CallstackEntry& Snapshot::callstack(int index) const {
  // @@protoc_insertion_point(field_get:debug.Snapshot.callstack)
  return _internal_callstack(index);
}
inline ::debug::CallstackEntry* Snapshot::_internal_add_callstack() {
  return _impl_.callstack_.Add();
}
inline ::debug::CallstackEntry* Snapshot::add_callstack() {
  ::debug::CallstackEntry* _add = _internal_add_callstack();
  // @@protoc_insertion_point(field_add:debug.Snapshot.callstack)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::CallstackEntry >&
Snapshot::callstack() const {
  // @@protoc_insertion_point(field_list:debug.Snapshot.callstack)
  return _impl_.callstack_;
}

// optional .debug.Locals locals = 6;
inline bool Snapshot::_internal_has_locals() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.locals_ != nullptr);
  return value;
}
inline bool Snapshot::has_locals() const {
  return _internal_has_locals();
}
inline void Snapshot::clear_locals() {
  if (_impl_.locals_ != nullptr) _impl_.locals_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::debug::Locals& Snapshot::_internal_locals() const {
  const ::debug::Locals* p = _impl_.locals_;
  return p != nullptr ? *p : reinterpret_cast<const ::debug::Locals&>(
      ::debug::_Locals_default_instance_);
}
inline const ::debug::Locals& Snapshot::locals() const {
  // @@protoc_insertion_point(field_get:debug.Snapshot.locals)
  return _internal_locals();
}
inline void Snapshot::unsafe_arena_set_allocated_locals(
    ::debug::Locals* locals) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.locals_);
  }
  _impl_.locals_ = locals;
  if (locals) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debug.Snapshot.locals)
}
inline ::debug::Locals* Snapshot::release_locals() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::debug::Locals* temp = _impl_.locals_;
  _impl_.locals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::debug::Locals* Snapshot::unsafe_arena_release_locals() {
  // @@protoc_insertion_point(field_release:debug.Snapshot.locals)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::debug::Locals* temp = _impl_.locals_;
  _impl_.locals_ = nullptr;
  return temp;
}
inline ::debug::Locals* Snapshot::_internal_mutable_locals() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.locals_ == nullptr) {
    auto* p = CreateMaybeMessage<::debug::Locals>(GetArenaForAllocation());
    _impl_.locals_ = p;
  }
  return _impl_.locals_;
}
inline ::debug::Locals* Snapshot::mutable_locals() {
  ::debug::Locals* _msg = _internal_mutable_locals();
  // @@protoc_insertion_point(field_mutable:debug.Snapshot.locals)
  return _msg;
}
inline void Snapshot::set_allocated_locals(::debug::Locals* locals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.locals_;
  }
  if (locals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(locals);
    if (message_arena != submessage_arena) {
      locals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, locals, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.locals_ = locals;
  // @@protoc_insertion_point(field_set_allocated:debug.Snapshot.locals)
}

// optional .debug.EventsQueue queue = 7;
inline bool Snapshot::_internal_has_queue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.queue_ != nullptr);
  return value;
}
inline bool Snapshot::has_queue() const {
  return _internal_has_queue();
}
inline void Snapshot::clear_queue() {
  if (_impl_.queue_ != nullptr) _impl_.queue_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::debug::EventsQueue& Snapshot::_internal_queue() const {
  const ::debug::EventsQueue* p = _impl_.queue_;
  return p != nullptr ? *p : reinterpret_cast<const ::debug::EventsQueue&>(
      ::debug::_EventsQueue_default_instance_);
}
inline const ::debug::EventsQueue& Snapshot::queue() const {
  // @@protoc_insertion_point(field_get:debug.Snapshot.queue)
  return _internal_queue();
}
inline void Snapshot::unsafe_arena_set_allocated_queue(
    ::debug::EventsQueue* queue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.queue_);
  }
  _impl_.queue_ = queue;
  if (queue) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debug.Snapshot.queue)
}
inline ::debug::EventsQueue* Snapshot::release_queue() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::debug::EventsQueue* temp = _impl_.queue_;
  _impl_.queue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::debug::EventsQueue* Snapshot::unsafe_arena_release_queue() {
  // @@protoc_insertion_point(field_release:debug.Snapshot.queue)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::debug::EventsQueue* temp = _impl_.queue_;
  _impl_.queue_ = nullptr;
  return temp;
}
inline ::debug::EventsQueue* Snapshot::_internal_mutable_queue() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.queue_ == nullptr) {
    auto* p = CreateMaybeMessage<::debug::EventsQueue>(GetArenaForAllocation());
    _impl_.queue_ = p;
  }
  return _impl_.queue_;
}
inline ::debug::EventsQueue* Snapshot::mutable_queue() {
  ::debug::EventsQueue* _msg = _internal_mutable_queue();
  // @@protoc_insertion_point(field_mutable:debug.Snapshot.queue)
  return _msg;
}
inline void Snapshot::set_allocated_queue(::debug::EventsQueue* queue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.queue_;
  }
  if (queue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(queue);
    if (message_arena != submessage_arena) {
      queue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, queue, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.queue_ = queue;
  // @@protoc_insertion_point(field_set_allocated:debug.Snapshot.queue)
}

// optional .debug.CallbackMapping callbacks = 8;
inline bool Snapshot::_internal_has_callbacks() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.callbacks_ != nullptr);
  return value;
}
inline bool Snapshot::has_callbacks() const {
  return _internal_has_callbacks();
}
inline void Snapshot::clear_callbacks() {
  if (_impl_.callbacks_ != nullptr) _impl_.callbacks_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::debug::CallbackMapping& Snapshot::_internal_callbacks() const {
  const ::debug::CallbackMapping* p = _impl_.callbacks_;
  return p != nullptr ? *p : reinterpret_cast<const ::debug::CallbackMapping&>(
      ::debug::_CallbackMapping_default_instance_);
}
inline const ::debug::CallbackMapping& Snapshot::callbacks() const {
  // @@protoc_insertion_point(field_get:debug.Snapshot.callbacks)
  return _internal_callbacks();
}
inline void Snapshot::unsafe_arena_set_allocated_callbacks(
    ::debug::CallbackMapping* callbacks) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.callbacks_);
  }
  _impl_.callbacks_ = callbacks;
  if (callbacks) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debug.Snapshot.callbacks)
}
inline ::debug::CallbackMapping* Snapshot::release_callbacks() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::debug::CallbackMapping* temp = _impl_.callbacks_;
  _impl_.callbacks_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::debug::CallbackMapping* Snapshot::unsafe_arena_release_callbacks() {
  // @@protoc_insertion_point(field_release:debug.Snapshot.callbacks)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::debug::CallbackMapping* temp = _impl_.callbacks_;
  _impl_.callbacks_ = nullptr;
  return temp;
}
inline ::debug::CallbackMapping* Snapshot::_internal_mutable_callbacks() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.callbacks_ == nullptr) {
    auto* p = CreateMaybeMessage<::debug::CallbackMapping>(GetArenaForAllocation());
    _impl_.callbacks_ = p;
  }
  return _impl_.callbacks_;
}
inline ::debug::CallbackMapping* Snapshot::mutable_callbacks() {
  ::debug::CallbackMapping* _msg = _internal_mutable_callbacks();
  // @@protoc_insertion_point(field_mutable:debug.Snapshot.callbacks)
  return _msg;
}
inline void Snapshot::set_allocated_callbacks(::debug::CallbackMapping* callbacks) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.callbacks_;
  }
  if (callbacks) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(callbacks);
    if (message_arena != submessage_arena) {
      callbacks = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, callbacks, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.callbacks_ = callbacks;
  // @@protoc_insertion_point(field_set_allocated:debug.Snapshot.callbacks)
}

// -------------------------------------------------------------------

// Function

// int32 fidx = 1;
inline void Function::clear_fidx() {
  _impl_.fidx_ = 0;
}
inline int32_t Function::_internal_fidx() const {
  return _impl_.fidx_;
}
inline int32_t Function::fidx() const {
  // @@protoc_insertion_point(field_get:debug.Function.fidx)
  return _internal_fidx();
}
inline void Function::_internal_set_fidx(int32_t value) {
  
  _impl_.fidx_ = value;
}
inline void Function::set_fidx(int32_t value) {
  _internal_set_fidx(value);
  // @@protoc_insertion_point(field_set:debug.Function.fidx)
}

// .debug.Range range = 2;
inline bool Function::_internal_has_range() const {
  return this != internal_default_instance() && _impl_.range_ != nullptr;
}
inline bool Function::has_range() const {
  return _internal_has_range();
}
inline void Function::clear_range() {
  if (GetArenaForAllocation() == nullptr && _impl_.range_ != nullptr) {
    delete _impl_.range_;
  }
  _impl_.range_ = nullptr;
}
inline const ::debug::Range& Function::_internal_range() const {
  const ::debug::Range* p = _impl_.range_;
  return p != nullptr ? *p : reinterpret_cast<const ::debug::Range&>(
      ::debug::_Range_default_instance_);
}
inline const ::debug::Range& Function::range() const {
  // @@protoc_insertion_point(field_get:debug.Function.range)
  return _internal_range();
}
inline void Function::unsafe_arena_set_allocated_range(
    ::debug::Range* range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.range_);
  }
  _impl_.range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debug.Function.range)
}
inline ::debug::Range* Function::release_range() {
  
  ::debug::Range* temp = _impl_.range_;
  _impl_.range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::debug::Range* Function::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_release:debug.Function.range)
  
  ::debug::Range* temp = _impl_.range_;
  _impl_.range_ = nullptr;
  return temp;
}
inline ::debug::Range* Function::_internal_mutable_range() {
  
  if (_impl_.range_ == nullptr) {
    auto* p = CreateMaybeMessage<::debug::Range>(GetArenaForAllocation());
    _impl_.range_ = p;
  }
  return _impl_.range_;
}
inline ::debug::Range* Function::mutable_range() {
  ::debug::Range* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:debug.Function.range)
  return _msg;
}
inline void Function::set_allocated_range(::debug::Range* range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.range_;
  }
  if (range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(range);
    if (message_arena != submessage_arena) {
      range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.range_ = range;
  // @@protoc_insertion_point(field_set_allocated:debug.Function.range)
}

// .debug.Locals locals = 3;
inline bool Function::_internal_has_locals() const {
  return this != internal_default_instance() && _impl_.locals_ != nullptr;
}
inline bool Function::has_locals() const {
  return _internal_has_locals();
}
inline void Function::clear_locals() {
  if (GetArenaForAllocation() == nullptr && _impl_.locals_ != nullptr) {
    delete _impl_.locals_;
  }
  _impl_.locals_ = nullptr;
}
inline const ::debug::Locals& Function::_internal_locals() const {
  const ::debug::Locals* p = _impl_.locals_;
  return p != nullptr ? *p : reinterpret_cast<const ::debug::Locals&>(
      ::debug::_Locals_default_instance_);
}
inline const ::debug::Locals& Function::locals() const {
  // @@protoc_insertion_point(field_get:debug.Function.locals)
  return _internal_locals();
}
inline void Function::unsafe_arena_set_allocated_locals(
    ::debug::Locals* locals) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.locals_);
  }
  _impl_.locals_ = locals;
  if (locals) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debug.Function.locals)
}
inline ::debug::Locals* Function::release_locals() {
  
  ::debug::Locals* temp = _impl_.locals_;
  _impl_.locals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::debug::Locals* Function::unsafe_arena_release_locals() {
  // @@protoc_insertion_point(field_release:debug.Function.locals)
  
  ::debug::Locals* temp = _impl_.locals_;
  _impl_.locals_ = nullptr;
  return temp;
}
inline ::debug::Locals* Function::_internal_mutable_locals() {
  
  if (_impl_.locals_ == nullptr) {
    auto* p = CreateMaybeMessage<::debug::Locals>(GetArenaForAllocation());
    _impl_.locals_ = p;
  }
  return _impl_.locals_;
}
inline ::debug::Locals* Function::mutable_locals() {
  ::debug::Locals* _msg = _internal_mutable_locals();
  // @@protoc_insertion_point(field_mutable:debug.Function.locals)
  return _msg;
}
inline void Function::set_allocated_locals(::debug::Locals* locals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.locals_;
  }
  if (locals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(locals);
    if (message_arena != submessage_arena) {
      locals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, locals, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.locals_ = locals;
  // @@protoc_insertion_point(field_set_allocated:debug.Function.locals)
}

// bytes instructions = 4;
inline void Function::clear_instructions() {
  _impl_.instructions_.ClearToEmpty();
}
inline const std::string& Function::instructions() const {
  // @@protoc_insertion_point(field_get:debug.Function.instructions)
  return _internal_instructions();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Function::set_instructions(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instructions_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:debug.Function.instructions)
}
inline std::string* Function::mutable_instructions() {
  std::string* _s = _internal_mutable_instructions();
  // @@protoc_insertion_point(field_mutable:debug.Function.instructions)
  return _s;
}
inline const std::string& Function::_internal_instructions() const {
  return _impl_.instructions_.Get();
}
inline void Function::_internal_set_instructions(const std::string& value) {
  
  _impl_.instructions_.Set(value, GetArenaForAllocation());
}
inline std::string* Function::_internal_mutable_instructions() {
  
  return _impl_.instructions_.Mutable(GetArenaForAllocation());
}
inline std::string* Function::release_instructions() {
  // @@protoc_insertion_point(field_release:debug.Function.instructions)
  return _impl_.instructions_.Release();
}
inline void Function::set_allocated_instructions(std::string* instructions) {
  if (instructions != nullptr) {
    
  } else {
    
  }
  _impl_.instructions_.SetAllocated(instructions, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instructions_.IsDefault()) {
    _impl_.instructions_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:debug.Function.instructions)
}

// -------------------------------------------------------------------

// RFC

// int32 fidx = 1;
inline void RFC::clear_fidx() {
  _impl_.fidx_ = 0;
}
inline int32_t RFC::_internal_fidx() const {
  return _impl_.fidx_;
}
inline int32_t RFC::fidx() const {
  // @@protoc_insertion_point(field_get:debug.RFC.fidx)
  return _internal_fidx();
}
inline void RFC::_internal_set_fidx(int32_t value) {
  
  _impl_.fidx_ = value;
}
inline void RFC::set_fidx(int32_t value) {
  _internal_set_fidx(value);
  // @@protoc_insertion_point(field_set:debug.RFC.fidx)
}

// int32 argcount = 2;
inline void RFC::clear_argcount() {
  _impl_.argcount_ = 0;
}
inline int32_t RFC::_internal_argcount() const {
  return _impl_.argcount_;
}
inline int32_t RFC::argcount() const {
  // @@protoc_insertion_point(field_get:debug.RFC.argcount)
  return _internal_argcount();
}
inline void RFC::_internal_set_argcount(int32_t value) {
  
  _impl_.argcount_ = value;
}
inline void RFC::set_argcount(int32_t value) {
  _internal_set_argcount(value);
  // @@protoc_insertion_point(field_set:debug.RFC.argcount)
}

// repeated .debug.Value args = 3;
inline int RFC::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int RFC::args_size() const {
  return _internal_args_size();
}
inline void RFC::clear_args() {
  _impl_.args_.Clear();
}
inline ::debug::Value* RFC::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:debug.RFC.args)
  return _impl_.args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Value >*
RFC::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:debug.RFC.args)
  return &_impl_.args_;
}
inline const ::debug::Value& RFC::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const ::debug::Value& RFC::args(int index) const {
  // @@protoc_insertion_point(field_get:debug.RFC.args)
  return _internal_args(index);
}
inline ::debug::Value* RFC::_internal_add_args() {
  return _impl_.args_.Add();
}
inline ::debug::Value* RFC::add_args() {
  ::debug::Value* _add = _internal_add_args();
  // @@protoc_insertion_point(field_add:debug.RFC.args)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Value >&
RFC::args() const {
  // @@protoc_insertion_point(field_list:debug.RFC.args)
  return _impl_.args_;
}

// -------------------------------------------------------------------

// CallstackEntry

// int32 type = 1;
inline void CallstackEntry::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t CallstackEntry::_internal_type() const {
  return _impl_.type_;
}
inline int32_t CallstackEntry::type() const {
  // @@protoc_insertion_point(field_get:debug.CallstackEntry.type)
  return _internal_type();
}
inline void CallstackEntry::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void CallstackEntry::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:debug.CallstackEntry.type)
}

// int32 fidx = 2;
inline void CallstackEntry::clear_fidx() {
  _impl_.fidx_ = 0;
}
inline int32_t CallstackEntry::_internal_fidx() const {
  return _impl_.fidx_;
}
inline int32_t CallstackEntry::fidx() const {
  // @@protoc_insertion_point(field_get:debug.CallstackEntry.fidx)
  return _internal_fidx();
}
inline void CallstackEntry::_internal_set_fidx(int32_t value) {
  
  _impl_.fidx_ = value;
}
inline void CallstackEntry::set_fidx(int32_t value) {
  _internal_set_fidx(value);
  // @@protoc_insertion_point(field_set:debug.CallstackEntry.fidx)
}

// int32 sp = 3;
inline void CallstackEntry::clear_sp() {
  _impl_.sp_ = 0;
}
inline int32_t CallstackEntry::_internal_sp() const {
  return _impl_.sp_;
}
inline int32_t CallstackEntry::sp() const {
  // @@protoc_insertion_point(field_get:debug.CallstackEntry.sp)
  return _internal_sp();
}
inline void CallstackEntry::_internal_set_sp(int32_t value) {
  
  _impl_.sp_ = value;
}
inline void CallstackEntry::set_sp(int32_t value) {
  _internal_set_sp(value);
  // @@protoc_insertion_point(field_set:debug.CallstackEntry.sp)
}

// int32 fp = 4;
inline void CallstackEntry::clear_fp() {
  _impl_.fp_ = 0;
}
inline int32_t CallstackEntry::_internal_fp() const {
  return _impl_.fp_;
}
inline int32_t CallstackEntry::fp() const {
  // @@protoc_insertion_point(field_get:debug.CallstackEntry.fp)
  return _internal_fp();
}
inline void CallstackEntry::_internal_set_fp(int32_t value) {
  
  _impl_.fp_ = value;
}
inline void CallstackEntry::set_fp(int32_t value) {
  _internal_set_fp(value);
  // @@protoc_insertion_point(field_set:debug.CallstackEntry.fp)
}

// int32 start = 5;
inline void CallstackEntry::clear_start() {
  _impl_.start_ = 0;
}
inline int32_t CallstackEntry::_internal_start() const {
  return _impl_.start_;
}
inline int32_t CallstackEntry::start() const {
  // @@protoc_insertion_point(field_get:debug.CallstackEntry.start)
  return _internal_start();
}
inline void CallstackEntry::_internal_set_start(int32_t value) {
  
  _impl_.start_ = value;
}
inline void CallstackEntry::set_start(int32_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:debug.CallstackEntry.start)
}

// int32 ra = 6;
inline void CallstackEntry::clear_ra() {
  _impl_.ra_ = 0;
}
inline int32_t CallstackEntry::_internal_ra() const {
  return _impl_.ra_;
}
inline int32_t CallstackEntry::ra() const {
  // @@protoc_insertion_point(field_get:debug.CallstackEntry.ra)
  return _internal_ra();
}
inline void CallstackEntry::_internal_set_ra(int32_t value) {
  
  _impl_.ra_ = value;
}
inline void CallstackEntry::set_ra(int32_t value) {
  _internal_set_ra(value);
  // @@protoc_insertion_point(field_set:debug.CallstackEntry.ra)
}

// -------------------------------------------------------------------

// Locals

// int32 count = 1;
inline void Locals::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t Locals::_internal_count() const {
  return _impl_.count_;
}
inline int32_t Locals::count() const {
  // @@protoc_insertion_point(field_get:debug.Locals.count)
  return _internal_count();
}
inline void Locals::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void Locals::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:debug.Locals.count)
}

// repeated .debug.Value values = 2;
inline int Locals::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Locals::values_size() const {
  return _internal_values_size();
}
inline void Locals::clear_values() {
  _impl_.values_.Clear();
}
inline ::debug::Value* Locals::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:debug.Locals.values)
  return _impl_.values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Value >*
Locals::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:debug.Locals.values)
  return &_impl_.values_;
}
inline const ::debug::Value& Locals::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline const ::debug::Value& Locals::values(int index) const {
  // @@protoc_insertion_point(field_get:debug.Locals.values)
  return _internal_values(index);
}
inline ::debug::Value* Locals::_internal_add_values() {
  return _impl_.values_.Add();
}
inline ::debug::Value* Locals::add_values() {
  ::debug::Value* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:debug.Locals.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Value >&
Locals::values() const {
  // @@protoc_insertion_point(field_list:debug.Locals.values)
  return _impl_.values_;
}

// -------------------------------------------------------------------

// Value

// .debug.Value.Type type = 1;
inline void Value::clear_type() {
  _impl_.type_ = 0;
}
inline ::debug::Value_Type Value::_internal_type() const {
  return static_cast< ::debug::Value_Type >(_impl_.type_);
}
inline ::debug::Value_Type Value::type() const {
  // @@protoc_insertion_point(field_get:debug.Value.type)
  return _internal_type();
}
inline void Value::_internal_set_type(::debug::Value_Type value) {
  
  _impl_.type_ = value;
}
inline void Value::set_type(::debug::Value_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:debug.Value.type)
}

// string value = 2;
inline void Value::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Value::value() const {
  // @@protoc_insertion_point(field_get:debug.Value.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Value::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:debug.Value.value)
}
inline std::string* Value::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:debug.Value.value)
  return _s;
}
inline const std::string& Value::_internal_value() const {
  return _impl_.value_.Get();
}
inline void Value::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Value::release_value() {
  // @@protoc_insertion_point(field_release:debug.Value.value)
  return _impl_.value_.Release();
}
inline void Value::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:debug.Value.value)
}

// int32 index = 3;
inline void Value::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t Value::_internal_index() const {
  return _impl_.index_;
}
inline int32_t Value::index() const {
  // @@protoc_insertion_point(field_get:debug.Value.index)
  return _internal_index();
}
inline void Value::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void Value::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:debug.Value.index)
}

// -------------------------------------------------------------------

// CallbackMapping

// repeated .debug.CallbackEntry entries = 1;
inline int CallbackMapping::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int CallbackMapping::entries_size() const {
  return _internal_entries_size();
}
inline void CallbackMapping::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::debug::CallbackEntry* CallbackMapping::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:debug.CallbackMapping.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::CallbackEntry >*
CallbackMapping::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:debug.CallbackMapping.entries)
  return &_impl_.entries_;
}
inline const ::debug::CallbackEntry& CallbackMapping::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::debug::CallbackEntry& CallbackMapping::entries(int index) const {
  // @@protoc_insertion_point(field_get:debug.CallbackMapping.entries)
  return _internal_entries(index);
}
inline ::debug::CallbackEntry* CallbackMapping::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::debug::CallbackEntry* CallbackMapping::add_entries() {
  ::debug::CallbackEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:debug.CallbackMapping.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::CallbackEntry >&
CallbackMapping::entries() const {
  // @@protoc_insertion_point(field_list:debug.CallbackMapping.entries)
  return _impl_.entries_;
}

// -------------------------------------------------------------------

// CallbackEntry

// string topic = 1;
inline void CallbackEntry::clear_topic() {
  _impl_.topic_.ClearToEmpty();
}
inline const std::string& CallbackEntry::topic() const {
  // @@protoc_insertion_point(field_get:debug.CallbackEntry.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallbackEntry::set_topic(ArgT0&& arg0, ArgT... args) {
 
 _impl_.topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:debug.CallbackEntry.topic)
}
inline std::string* CallbackEntry::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:debug.CallbackEntry.topic)
  return _s;
}
inline const std::string& CallbackEntry::_internal_topic() const {
  return _impl_.topic_.Get();
}
inline void CallbackEntry::_internal_set_topic(const std::string& value) {
  
  _impl_.topic_.Set(value, GetArenaForAllocation());
}
inline std::string* CallbackEntry::_internal_mutable_topic() {
  
  return _impl_.topic_.Mutable(GetArenaForAllocation());
}
inline std::string* CallbackEntry::release_topic() {
  // @@protoc_insertion_point(field_release:debug.CallbackEntry.topic)
  return _impl_.topic_.Release();
}
inline void CallbackEntry::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  _impl_.topic_.SetAllocated(topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:debug.CallbackEntry.topic)
}

// repeated int32 tidx = 2;
inline int CallbackEntry::_internal_tidx_size() const {
  return _impl_.tidx_.size();
}
inline int CallbackEntry::tidx_size() const {
  return _internal_tidx_size();
}
inline void CallbackEntry::clear_tidx() {
  _impl_.tidx_.Clear();
}
inline int32_t CallbackEntry::_internal_tidx(int index) const {
  return _impl_.tidx_.Get(index);
}
inline int32_t CallbackEntry::tidx(int index) const {
  // @@protoc_insertion_point(field_get:debug.CallbackEntry.tidx)
  return _internal_tidx(index);
}
inline void CallbackEntry::set_tidx(int index, int32_t value) {
  _impl_.tidx_.Set(index, value);
  // @@protoc_insertion_point(field_set:debug.CallbackEntry.tidx)
}
inline void CallbackEntry::_internal_add_tidx(int32_t value) {
  _impl_.tidx_.Add(value);
}
inline void CallbackEntry::add_tidx(int32_t value) {
  _internal_add_tidx(value);
  // @@protoc_insertion_point(field_add:debug.CallbackEntry.tidx)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
CallbackEntry::_internal_tidx() const {
  return _impl_.tidx_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
CallbackEntry::tidx() const {
  // @@protoc_insertion_point(field_list:debug.CallbackEntry.tidx)
  return _internal_tidx();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
CallbackEntry::_internal_mutable_tidx() {
  return &_impl_.tidx_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
CallbackEntry::mutable_tidx() {
  // @@protoc_insertion_point(field_mutable_list:debug.CallbackEntry.tidx)
  return _internal_mutable_tidx();
}

// -------------------------------------------------------------------

// EventsQueue

// int32 count = 1;
inline void EventsQueue::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t EventsQueue::_internal_count() const {
  return _impl_.count_;
}
inline int32_t EventsQueue::count() const {
  // @@protoc_insertion_point(field_get:debug.EventsQueue.count)
  return _internal_count();
}
inline void EventsQueue::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void EventsQueue::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:debug.EventsQueue.count)
}

// repeated .debug.Event events = 2;
inline int EventsQueue::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int EventsQueue::events_size() const {
  return _internal_events_size();
}
inline void EventsQueue::clear_events() {
  _impl_.events_.Clear();
}
inline ::debug::Event* EventsQueue::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:debug.EventsQueue.events)
  return _impl_.events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Event >*
EventsQueue::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:debug.EventsQueue.events)
  return &_impl_.events_;
}
inline const ::debug::Event& EventsQueue::_internal_events(int index) const {
  return _impl_.events_.Get(index);
}
inline const ::debug::Event& EventsQueue::events(int index) const {
  // @@protoc_insertion_point(field_get:debug.EventsQueue.events)
  return _internal_events(index);
}
inline ::debug::Event* EventsQueue::_internal_add_events() {
  return _impl_.events_.Add();
}
inline ::debug::Event* EventsQueue::add_events() {
  ::debug::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:debug.EventsQueue.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::debug::Event >&
EventsQueue::events() const {
  // @@protoc_insertion_point(field_list:debug.EventsQueue.events)
  return _impl_.events_;
}

// optional .debug.Range range = 3;
inline bool EventsQueue::_internal_has_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.range_ != nullptr);
  return value;
}
inline bool EventsQueue::has_range() const {
  return _internal_has_range();
}
inline void EventsQueue::clear_range() {
  if (_impl_.range_ != nullptr) _impl_.range_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::debug::Range& EventsQueue::_internal_range() const {
  const ::debug::Range* p = _impl_.range_;
  return p != nullptr ? *p : reinterpret_cast<const ::debug::Range&>(
      ::debug::_Range_default_instance_);
}
inline const ::debug::Range& EventsQueue::range() const {
  // @@protoc_insertion_point(field_get:debug.EventsQueue.range)
  return _internal_range();
}
inline void EventsQueue::unsafe_arena_set_allocated_range(
    ::debug::Range* range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.range_);
  }
  _impl_.range_ = range;
  if (range) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debug.EventsQueue.range)
}
inline ::debug::Range* EventsQueue::release_range() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::debug::Range* temp = _impl_.range_;
  _impl_.range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::debug::Range* EventsQueue::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_release:debug.EventsQueue.range)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::debug::Range* temp = _impl_.range_;
  _impl_.range_ = nullptr;
  return temp;
}
inline ::debug::Range* EventsQueue::_internal_mutable_range() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.range_ == nullptr) {
    auto* p = CreateMaybeMessage<::debug::Range>(GetArenaForAllocation());
    _impl_.range_ = p;
  }
  return _impl_.range_;
}
inline ::debug::Range* EventsQueue::mutable_range() {
  ::debug::Range* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:debug.EventsQueue.range)
  return _msg;
}
inline void EventsQueue::set_allocated_range(::debug::Range* range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.range_;
  }
  if (range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(range);
    if (message_arena != submessage_arena) {
      range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.range_ = range;
  // @@protoc_insertion_point(field_set_allocated:debug.EventsQueue.range)
}

// -------------------------------------------------------------------

// Event

// string topic = 1;
inline void Event::clear_topic() {
  _impl_.topic_.ClearToEmpty();
}
inline const std::string& Event::topic() const {
  // @@protoc_insertion_point(field_get:debug.Event.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_topic(ArgT0&& arg0, ArgT... args) {
 
 _impl_.topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:debug.Event.topic)
}
inline std::string* Event::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:debug.Event.topic)
  return _s;
}
inline const std::string& Event::_internal_topic() const {
  return _impl_.topic_.Get();
}
inline void Event::_internal_set_topic(const std::string& value) {
  
  _impl_.topic_.Set(value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_topic() {
  
  return _impl_.topic_.Mutable(GetArenaForAllocation());
}
inline std::string* Event::release_topic() {
  // @@protoc_insertion_point(field_release:debug.Event.topic)
  return _impl_.topic_.Release();
}
inline void Event::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  _impl_.topic_.SetAllocated(topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:debug.Event.topic)
}

// string payload = 2;
inline void Event::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& Event::payload() const {
  // @@protoc_insertion_point(field_get:debug.Event.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:debug.Event.payload)
}
inline std::string* Event::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:debug.Event.payload)
  return _s;
}
inline const std::string& Event::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void Event::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* Event::release_payload() {
  // @@protoc_insertion_point(field_release:debug.Event.payload)
  return _impl_.payload_.Release();
}
inline void Event::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:debug.Event.payload)
}

// -------------------------------------------------------------------

// Range

// int32 start = 1;
inline void Range::clear_start() {
  _impl_.start_ = 0;
}
inline int32_t Range::_internal_start() const {
  return _impl_.start_;
}
inline int32_t Range::start() const {
  // @@protoc_insertion_point(field_get:debug.Range.start)
  return _internal_start();
}
inline void Range::_internal_set_start(int32_t value) {
  
  _impl_.start_ = value;
}
inline void Range::set_start(int32_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:debug.Range.start)
}

// int32 end = 2;
inline void Range::clear_end() {
  _impl_.end_ = 0;
}
inline int32_t Range::_internal_end() const {
  return _impl_.end_;
}
inline int32_t Range::end() const {
  // @@protoc_insertion_point(field_get:debug.Range.end)
  return _internal_end();
}
inline void Range::_internal_set_end(int32_t value) {
  
  _impl_.end_ = value;
}
inline void Range::set_end(int32_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:debug.Range.end)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace debug

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::debug::Notification_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::debug::Value_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::debug::State> : ::std::true_type {};
template <> struct is_proto_enum< ::debug::Command> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_debug_2eproto
