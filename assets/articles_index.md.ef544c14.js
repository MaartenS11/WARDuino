import{c as a}from"./chunks/citation.17b5186b.js";import{o as t,c as o,J as r,V as i,C as e,a as n}from"./chunks/framework.cf01d80e.js";const s=i('<h1 id="research-articles" tabindex="-1">Research Articles <a class="header-anchor" href="#research-articles" aria-label="Permalink to &quot;Research Articles&quot;">​</a></h1><h2 id="edward-2022" tabindex="-1">EDWARD (2022) <a class="header-anchor" href="#edward-2022" aria-label="Permalink to &quot;EDWARD (2022)&quot;">​</a></h2><p>EDWARD is the novel <i>out-of-place</i> debugger for WARDuino, developed to simplify debugging concurrent programs. The EDWARD debugger allows developers to debug programs largely on their own laptop—thereby enabling more advanced debugging techniques—while using a remote microcontroller as a zombie that can still provide realtime peripheral data. Asynchronous events on the remote zombie are captured by the local debugger, and a new set of debugging instructions give developers control over the timings of the events.</p><p>More information can be found in the <a href="/WARDuino/reference/edward/">EDWARD reference</a>.</p>',4),l=e("h2",{id:"warduino-2019",tabindex:"-1"},[n("WARDuino (2019) "),e("a",{class:"header-anchor",href:"#warduino-2019","aria-label":'Permalink to "WARDuino (2019)"'},"​")],-1),d=e("p",null,"WARDuino was the first WebAssembly virtual machine to target microcontrollers, such as the ESP32s, and included a remote debugger and support for partial over-the-air reprogramming of the devices.",-1),_=JSON.parse('{"title":"Research Articles","description":"","frontmatter":{},"headers":[],"relativePath":"articles/index.md","filePath":"articles/index.md","lastUpdated":null}'),c={name:"articles/index.md"},b=Object.assign(c,{setup(h){return(u,p)=>(t(),o("div",null,[s,r(a,{file:"/edward.bib",url:"https://doi.org/10.1145/3546918.3546920"}),l,d,r(a,{file:"/warduino.bib",url:"https://doi.org/10.1145/3357390.3361029"})]))}});export{_ as __pageData,b as default};
